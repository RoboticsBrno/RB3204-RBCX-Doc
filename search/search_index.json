{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RBCX Documentation","title":"Home"},{"location":"#rbcx-documentation","text":"","title":"RBCX Documentation"},{"location":"snippetsExample/","text":"Snippets example Error: Did not find Function with name: `readUltra (bool async)` 1 2 3 4 5 6 7 :: : doxy.Function name : readUltra (bool async) details : True implements : True Available : None Source code 1 2 3 4 :: : doxy.Function name : readUltra (bool async) details : True implements : True Class rb::MotorChangeBuilder Class List > rb > MotorChangeBuilder Helper class for building the motor change event. #include <RBCXManager.h> Public Functions Type Name MotorChangeBuilder () MotorChangeBuilder (const MotorChangeBuilder & o) = delete MotorChangeBuilder ( MotorChangeBuilder && o) MotorChangeBuilder & brake (MotorId id, uint16_t brakingPower) Start braking. MotorChangeBuilder & drive (MotorId id, int32_t positionRelative, int16_t speedTicksPerSecond, Motor::callback_t callback=nullptr) MotorChangeBuilder & driveToValue (MotorId id, int32_t positionAbsolute, int16_t speedTicksPerSecond, Motor::callback_t callback=nullptr) MotorChangeBuilder & power (MotorId id, int16_t value) Set single motor power. MotorChangeBuilder & pwmMaxPercent (MotorId id, int8_t percent) Limit motor index's power to percent. void set () Finish the changes and submit the events. MotorChangeBuilder & speed (MotorId id, int16_t ticksPerSecond) Set single motor power. ~MotorChangeBuilder () Public Functions Documentation function MotorChangeBuilder [1/3] 1 rb :: MotorChangeBuilder :: MotorChangeBuilder () function MotorChangeBuilder [2/3] 1 2 3 rb :: MotorChangeBuilder :: MotorChangeBuilder ( const MotorChangeBuilder & o ) = delete function MotorChangeBuilder [3/3] 1 2 3 rb :: MotorChangeBuilder :: MotorChangeBuilder ( MotorChangeBuilder && o ) function brake 1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: brake ( MotorId id , uint16_t brakingPower ) function drive 1 2 3 4 5 6 MotorChangeBuilder & rb :: MotorChangeBuilder :: drive ( MotorId id , int32_t positionRelative , int16_t speedTicksPerSecond , Motor :: callback_t callback = nullptr ) function driveToValue 1 2 3 4 5 6 MotorChangeBuilder & rb :: MotorChangeBuilder :: driveToValue ( MotorId id , int32_t positionAbsolute , int16_t speedTicksPerSecond , Motor :: callback_t callback = nullptr ) function power 1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: power ( MotorId id , int16_t value ) function pwmMaxPercent 1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: pwmMaxPercent ( MotorId id , int8_t percent ) function set 1 void rb :: MotorChangeBuilder :: set () function speed 1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: speed ( MotorId id , int16_t ticksPerSecond ) function ~MotorChangeBuilder 1 rb :: MotorChangeBuilder ::~ MotorChangeBuilder () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXManager.h Source code 1 2 3 4 :: : doxy.Class name : rb::MotorChangeBuilder description : True include : True function brake 1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: brake ( MotorId id , uint16_t brakingPower ) Source code 1 2 3 4 5 :: : doxy.Class.Method name : rb::MotorChangeBuilder method : brake (MotorId id, uint16_t brakingPower) details : False include : True Class List Here are the classes, structs, unions and interfaces with brief descriptions: namespace rb class Angle class Battery Contains the battery state and can control the robot's power. class Buttons class Leds class Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. class Motor class MotorChangeBuilder Helper class for building the motor change event. class Nvs class Piezo Helper class for controlling the piezo. class SmartServoBus class StupidServo class Timers class Ultrasound struct servo_info struct timer_t Source code 1 :: : doxy.Class.list Class Index a Angle ( rb ) b Battery ( rb ) Buttons ( rb ) l Leds ( rb ) m Manager ( rb ) Motor ( rb ) MotorChangeBuilder ( rb ) n Nvs ( rb ) p Piezo ( rb ) s SmartServoBus ( rb ) StupidServo ( rb ) servo_info t Timers ( rb ) timer_t u Ultrasound ( rb ) Source code 1 :: : doxy.Class.index 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \"RBCXManager.h\" namespace rb { Leds :: Leds () : m_ledsOn {} {} Leds ::~ Leds () {} void Leds :: red ( bool on ) { byId ( LedId :: Red , on ); } void Leds :: yellow ( bool on ) { byId ( LedId :: Yellow , on ); } void Leds :: green ( bool on ) { byId ( LedId :: Green , on ); } void Leds :: blue ( bool on ) { byId ( LedId :: Blue , on ); } void Leds :: byId ( LedId id , bool on ) { std :: lock_guard < std :: mutex > l ( m_mutex ); auto newState = m_ledsOn ; if ( on ) { newState |= id ; } else { newState &= ~ id ; } if ( newState == m_ledsOn ) return ; m_ledsOn = newState ; const CoprocReq req = { . which_payload = CoprocReq_setLeds_tag , . payload = { . setLeds = { . ledsOn = ( CoprocReq_LedsEnum ) newState , } }, }; Manager :: get (). sendToCoproc ( req ); } }; Source code 1 2 :: : doxy.Code file : RBCXLeds.cpp File RBCXLeds.cpp 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 if ( on ) { newState |= id ; } else { newState &= ~ id ; } if ( newState == m_ledsOn ) return ; m_ledsOn = newState ; const CoprocReq req = { . which_payload = CoprocReq_setLeds_tag , . payload = { . setLeds = { . ledsOn = ( CoprocReq_LedsEnum ) newState , Source code 1 2 3 4 5 :: : doxy.Code file : RBCXLeds.cpp start : 21 end : 35 header : True","title":"Snippets example"},{"location":"snippetsExample/#snippets-example","text":"","title":"Snippets example"},{"location":"snippetsExample/#source-code","text":"1 2 3 4 :: : doxy.Function name : readUltra (bool async) details : True implements : True","title":"Source code"},{"location":"snippetsExample/#class-rbmotorchangebuilder","text":"Class List > rb > MotorChangeBuilder Helper class for building the motor change event. #include <RBCXManager.h>","title":"Class rb::MotorChangeBuilder"},{"location":"snippetsExample/#public-functions","text":"Type Name MotorChangeBuilder () MotorChangeBuilder (const MotorChangeBuilder & o) = delete MotorChangeBuilder ( MotorChangeBuilder && o) MotorChangeBuilder & brake (MotorId id, uint16_t brakingPower) Start braking. MotorChangeBuilder & drive (MotorId id, int32_t positionRelative, int16_t speedTicksPerSecond, Motor::callback_t callback=nullptr) MotorChangeBuilder & driveToValue (MotorId id, int32_t positionAbsolute, int16_t speedTicksPerSecond, Motor::callback_t callback=nullptr) MotorChangeBuilder & power (MotorId id, int16_t value) Set single motor power. MotorChangeBuilder & pwmMaxPercent (MotorId id, int8_t percent) Limit motor index's power to percent. void set () Finish the changes and submit the events. MotorChangeBuilder & speed (MotorId id, int16_t ticksPerSecond) Set single motor power. ~MotorChangeBuilder ()","title":"Public Functions"},{"location":"snippetsExample/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"snippetsExample/#function-motorchangebuilder-13","text":"1 rb :: MotorChangeBuilder :: MotorChangeBuilder ()","title":"function MotorChangeBuilder [1/3]"},{"location":"snippetsExample/#function-motorchangebuilder-23","text":"1 2 3 rb :: MotorChangeBuilder :: MotorChangeBuilder ( const MotorChangeBuilder & o ) = delete","title":"function MotorChangeBuilder [2/3]"},{"location":"snippetsExample/#function-motorchangebuilder-33","text":"1 2 3 rb :: MotorChangeBuilder :: MotorChangeBuilder ( MotorChangeBuilder && o )","title":"function MotorChangeBuilder [3/3]"},{"location":"snippetsExample/#function-brake","text":"1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: brake ( MotorId id , uint16_t brakingPower )","title":"function brake"},{"location":"snippetsExample/#function-drive","text":"1 2 3 4 5 6 MotorChangeBuilder & rb :: MotorChangeBuilder :: drive ( MotorId id , int32_t positionRelative , int16_t speedTicksPerSecond , Motor :: callback_t callback = nullptr )","title":"function drive"},{"location":"snippetsExample/#function-drivetovalue","text":"1 2 3 4 5 6 MotorChangeBuilder & rb :: MotorChangeBuilder :: driveToValue ( MotorId id , int32_t positionAbsolute , int16_t speedTicksPerSecond , Motor :: callback_t callback = nullptr )","title":"function driveToValue"},{"location":"snippetsExample/#function-power","text":"1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: power ( MotorId id , int16_t value )","title":"function power"},{"location":"snippetsExample/#function-pwmmaxpercent","text":"1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: pwmMaxPercent ( MotorId id , int8_t percent )","title":"function pwmMaxPercent"},{"location":"snippetsExample/#function-set","text":"1 void rb :: MotorChangeBuilder :: set ()","title":"function set"},{"location":"snippetsExample/#function-speed","text":"1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: speed ( MotorId id , int16_t ticksPerSecond )","title":"function speed"},{"location":"snippetsExample/#function-motorchangebuilder","text":"1 rb :: MotorChangeBuilder ::~ MotorChangeBuilder () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXManager.h","title":"function ~MotorChangeBuilder"},{"location":"snippetsExample/#source-code_1","text":"1 2 3 4 :: : doxy.Class name : rb::MotorChangeBuilder description : True include : True","title":"Source code"},{"location":"snippetsExample/#function-brake_1","text":"1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: brake ( MotorId id , uint16_t brakingPower )","title":"function brake"},{"location":"snippetsExample/#source-code_2","text":"1 2 3 4 5 :: : doxy.Class.Method name : rb::MotorChangeBuilder method : brake (MotorId id, uint16_t brakingPower) details : False include : True","title":"Source code"},{"location":"snippetsExample/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: namespace rb class Angle class Battery Contains the battery state and can control the robot's power. class Buttons class Leds class Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. class Motor class MotorChangeBuilder Helper class for building the motor change event. class Nvs class Piezo Helper class for controlling the piezo. class SmartServoBus class StupidServo class Timers class Ultrasound struct servo_info struct timer_t","title":"Class List"},{"location":"snippetsExample/#source-code_3","text":"1 :: : doxy.Class.list","title":"Source code"},{"location":"snippetsExample/#class-index","text":"","title":"Class Index"},{"location":"snippetsExample/#a","text":"Angle ( rb )","title":"a"},{"location":"snippetsExample/#b","text":"Battery ( rb ) Buttons ( rb )","title":"b"},{"location":"snippetsExample/#l","text":"Leds ( rb )","title":"l"},{"location":"snippetsExample/#m","text":"Manager ( rb ) Motor ( rb ) MotorChangeBuilder ( rb )","title":"m"},{"location":"snippetsExample/#n","text":"Nvs ( rb )","title":"n"},{"location":"snippetsExample/#p","text":"Piezo ( rb )","title":"p"},{"location":"snippetsExample/#s","text":"SmartServoBus ( rb ) StupidServo ( rb ) servo_info","title":"s"},{"location":"snippetsExample/#t","text":"Timers ( rb ) timer_t","title":"t"},{"location":"snippetsExample/#u","text":"Ultrasound ( rb )","title":"u"},{"location":"snippetsExample/#source-code_4","text":"1 :: : doxy.Class.index 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \"RBCXManager.h\" namespace rb { Leds :: Leds () : m_ledsOn {} {} Leds ::~ Leds () {} void Leds :: red ( bool on ) { byId ( LedId :: Red , on ); } void Leds :: yellow ( bool on ) { byId ( LedId :: Yellow , on ); } void Leds :: green ( bool on ) { byId ( LedId :: Green , on ); } void Leds :: blue ( bool on ) { byId ( LedId :: Blue , on ); } void Leds :: byId ( LedId id , bool on ) { std :: lock_guard < std :: mutex > l ( m_mutex ); auto newState = m_ledsOn ; if ( on ) { newState |= id ; } else { newState &= ~ id ; } if ( newState == m_ledsOn ) return ; m_ledsOn = newState ; const CoprocReq req = { . which_payload = CoprocReq_setLeds_tag , . payload = { . setLeds = { . ledsOn = ( CoprocReq_LedsEnum ) newState , } }, }; Manager :: get (). sendToCoproc ( req ); } };","title":"Source code"},{"location":"snippetsExample/#source-code_5","text":"1 2 :: : doxy.Code file : RBCXLeds.cpp","title":"Source code"},{"location":"snippetsExample/#file-rbcxledscpp","text":"21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 if ( on ) { newState |= id ; } else { newState &= ~ id ; } if ( newState == m_ledsOn ) return ; m_ledsOn = newState ; const CoprocReq req = { . which_payload = CoprocReq_setLeds_tag , . payload = { . setLeds = { . ledsOn = ( CoprocReq_LedsEnum ) newState ,","title":"File RBCXLeds.cpp"},{"location":"snippetsExample/#source-code_6","text":"1 2 3 4 5 :: : doxy.Code file : RBCXLeds.cpp start : 21 end : 35 header : True","title":"Source code"},{"location":"api/annotated/","text":"Class List Here are the classes, structs, unions and interfaces with brief descriptions: namespace rb class Angle class Battery Contains the battery state and can control the robot's power. class Buttons class Leds class Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. class Motor class MotorChangeBuilder Helper class for building the motor change event. class Nvs class Piezo Helper class for controlling the piezo. class SmartServoBus class StupidServo class Timers class Ultrasound struct servo_info struct timer_t","title":"Class List"},{"location":"api/annotated/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: namespace rb class Angle class Battery Contains the battery state and can control the robot's power. class Buttons class Leds class Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. class Motor class MotorChangeBuilder Helper class for building the motor change event. class Nvs class Piezo Helper class for controlling the piezo. class SmartServoBus class StupidServo class Timers class Ultrasound struct servo_info struct timer_t","title":"Class List"},{"location":"api/files/","text":"File List Here is a list of all files with brief descriptions: dir build dir RB3204-RBCX-library dir src file RBCX.h file RBCXAngle.cpp file RBCXAngle.h file RBCXBattery.cpp file RBCXBattery.h file RBCXButtons.cpp file RBCXButtons.h file RBCXLeds.cpp file RBCXLeds.h file RBCXManager.cpp file RBCXManager.h file RBCXMotor.cpp file RBCXMotor.h file RBCXNvs.cpp file RBCXNvs.h file RBCXPiezo.cpp file RBCXPiezo.h file RBCXPinout.h file RBCXSmartServo.cpp file RBCXSmartServo.h file RBCXStupidServo.cpp file RBCXStupidServo.h file RBCXTimers.cpp file RBCXTimers.h file RBCXUltrasound.cpp file RBCXUltrasound.h file RBCXUtil.h file RBCXVersion.h","title":"Files"},{"location":"api/files/#file-list","text":"Here is a list of all files with brief descriptions: dir build dir RB3204-RBCX-library dir src file RBCX.h file RBCXAngle.cpp file RBCXAngle.h file RBCXBattery.cpp file RBCXBattery.h file RBCXButtons.cpp file RBCXButtons.h file RBCXLeds.cpp file RBCXLeds.h file RBCXManager.cpp file RBCXManager.h file RBCXMotor.cpp file RBCXMotor.h file RBCXNvs.cpp file RBCXNvs.h file RBCXPiezo.cpp file RBCXPiezo.h file RBCXPinout.h file RBCXSmartServo.cpp file RBCXSmartServo.h file RBCXStupidServo.cpp file RBCXStupidServo.h file RBCXTimers.cpp file RBCXTimers.h file RBCXUltrasound.cpp file RBCXUltrasound.h file RBCXUtil.h file RBCXVersion.h","title":"File List"},{"location":"api/namespacerb/","text":"Namespace rb Class List > rb Classes Type Name class Angle class Battery Contains the battery state and can control the robot's power. class Buttons class Leds class Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. class Motor class MotorChangeBuilder Helper class for building the motor change event. class Nvs class Piezo Helper class for controlling the piezo. class SmartServoBus class StupidServo class Timers class Ultrasound Public Types Type Name enum uint32_t ButtonId Helper class for controlling the LEDs connected to the expander. enum LedId Helper class for controlling the LEDs connected to the expander. enum ManagerInstallFlags This enum contains flags for the Manager 's install() method. enum uint8_t MotorId Public Static Attributes Type Name constexpr int StupidServosCount = = 4 constexpr int UltrasoundsCount = = 4 Public Functions Type Name T clamp (T value, T min, T max) void delay (std::chrono::duration< uint32_t, std::milli > delay) void delayMs (int ms) Angle operator\"\"_deg (long double d) Angle operator\"\"_deg (unsigned long long int d) Angle operator\"\"_rad (long double r) Angle operator\"\"_rad (unsigned long long int r) Angle operator* ( Angle a, Angle::_T c) Angle operator+ ( Angle a, Angle b) MotorId operator++ (MotorId & x) Angle operator- ( Angle a, Angle b) Angle operator/ ( Angle a, Angle::_T c) ManagerInstallFlags [**operator Public Static Functions Type Name void dieTimers (TimerHandle_t timer) Public Types Documentation enum ButtonId 1 2 3 4 5 6 7 8 9 10 11 12 enum rb :: ButtonId { Off = CoprocStat_ButtonsEnum_BOFF , On = CoprocStat_ButtonsEnum_BON , B1 = CoprocStat_ButtonsEnum_B1 , B2 = CoprocStat_ButtonsEnum_B2 , B3 = CoprocStat_ButtonsEnum_B3 , B4 = CoprocStat_ButtonsEnum_B4 , Up = B1 , Down = B2 , Left = B3 , Right = B4 }; enum LedId 1 2 3 4 5 6 7 8 9 10 11 enum rb :: LedId { L1 = CoprocReq_LedsEnum_L1 , L2 = CoprocReq_LedsEnum_L2 , L3 = CoprocReq_LedsEnum_L3 , L4 = CoprocReq_LedsEnum_L4 , Green = L1 , Yellow = L2 , Red = L3 , Blue = L4 , All = L1 | L2 | L3 | L4 }; enum ManagerInstallFlags 1 2 3 4 enum rb :: ManagerInstallFlags { MAN_NONE = 0 , MAN_DISABLE_MOTOR_FAILSAFE = ( 1 << 0 ) }; enum MotorId 1 2 3 4 5 6 7 enum rb :: MotorId { M1 , M2 , M3 , M4 , MAX }; Public Static Attributes Documentation variable StupidServosCount 1 constexpr int rb :: StupidServosCount ; variable UltrasoundsCount 1 constexpr int rb :: UltrasoundsCount ; Public Functions Documentation function clamp 1 2 3 4 5 6 template < typename T typename T > T rb :: clamp ( T value , T min , T max ) function delay 1 2 3 inline void rb :: delay ( std :: chrono :: duration < uint32_t , std :: milli > delay ) function delayMs 1 2 3 inline void rb :: delayMs ( int ms ) function operator\"\"_deg 1 2 3 Angle rb :: operator \"\" _deg ( long double d ) function operator\"\"_deg 1 2 3 Angle rb :: operator \"\" _deg ( unsigned long long int d ) function operator\"\"_rad 1 2 3 Angle rb :: operator \"\" _rad ( long double r ) function operator\"\"_rad 1 2 3 Angle rb :: operator \"\" _rad ( unsigned long long int r ) function operator* 1 2 3 4 Angle rb :: operator * ( Angle a , Angle :: _T c ) function operator+ 1 2 3 4 Angle rb :: operator + ( Angle a , Angle b ) function operator++ 1 2 3 inline MotorId rb :: operator ++ ( MotorId & x ) function operator- 1 2 3 4 Angle rb :: operator - ( Angle a , Angle b ) function operator/ 1 2 3 4 Angle rb :: operator / ( Angle a , Angle :: _T c ) function operator| 1 2 3 4 inline ManagerInstallFlags rb :: operator | ( ManagerInstallFlags a , ManagerInstallFlags b ) Public Static Functions Documentation function dieTimers 1 2 3 static void rb :: dieTimers ( TimerHandle_t timer ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXAngle.cpp","title":"Namespace rb"},{"location":"api/namespacerb/#namespace-rb","text":"Class List > rb","title":"Namespace rb"},{"location":"api/namespacerb/#classes","text":"Type Name class Angle class Battery Contains the battery state and can control the robot's power. class Buttons class Leds class Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. class Motor class MotorChangeBuilder Helper class for building the motor change event. class Nvs class Piezo Helper class for controlling the piezo. class SmartServoBus class StupidServo class Timers class Ultrasound","title":"Classes"},{"location":"api/namespacerb/#public-types","text":"Type Name enum uint32_t ButtonId Helper class for controlling the LEDs connected to the expander. enum LedId Helper class for controlling the LEDs connected to the expander. enum ManagerInstallFlags This enum contains flags for the Manager 's install() method. enum uint8_t MotorId","title":"Public Types"},{"location":"api/namespacerb/#public-static-attributes","text":"Type Name constexpr int StupidServosCount = = 4 constexpr int UltrasoundsCount = = 4","title":"Public Static Attributes"},{"location":"api/namespacerb/#public-functions","text":"Type Name T clamp (T value, T min, T max) void delay (std::chrono::duration< uint32_t, std::milli > delay) void delayMs (int ms) Angle operator\"\"_deg (long double d) Angle operator\"\"_deg (unsigned long long int d) Angle operator\"\"_rad (long double r) Angle operator\"\"_rad (unsigned long long int r) Angle operator* ( Angle a, Angle::_T c) Angle operator+ ( Angle a, Angle b) MotorId operator++ (MotorId & x) Angle operator- ( Angle a, Angle b) Angle operator/ ( Angle a, Angle::_T c) ManagerInstallFlags [**operator","title":"Public Functions"},{"location":"api/namespacerb/#public-static-functions","text":"Type Name void dieTimers (TimerHandle_t timer)","title":"Public Static Functions"},{"location":"api/namespacerb/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/namespacerb/#enum-buttonid","text":"1 2 3 4 5 6 7 8 9 10 11 12 enum rb :: ButtonId { Off = CoprocStat_ButtonsEnum_BOFF , On = CoprocStat_ButtonsEnum_BON , B1 = CoprocStat_ButtonsEnum_B1 , B2 = CoprocStat_ButtonsEnum_B2 , B3 = CoprocStat_ButtonsEnum_B3 , B4 = CoprocStat_ButtonsEnum_B4 , Up = B1 , Down = B2 , Left = B3 , Right = B4 };","title":"enum ButtonId"},{"location":"api/namespacerb/#enum-ledid","text":"1 2 3 4 5 6 7 8 9 10 11 enum rb :: LedId { L1 = CoprocReq_LedsEnum_L1 , L2 = CoprocReq_LedsEnum_L2 , L3 = CoprocReq_LedsEnum_L3 , L4 = CoprocReq_LedsEnum_L4 , Green = L1 , Yellow = L2 , Red = L3 , Blue = L4 , All = L1 | L2 | L3 | L4 };","title":"enum LedId"},{"location":"api/namespacerb/#enum-managerinstallflags","text":"1 2 3 4 enum rb :: ManagerInstallFlags { MAN_NONE = 0 , MAN_DISABLE_MOTOR_FAILSAFE = ( 1 << 0 ) };","title":"enum ManagerInstallFlags"},{"location":"api/namespacerb/#enum-motorid","text":"1 2 3 4 5 6 7 enum rb :: MotorId { M1 , M2 , M3 , M4 , MAX };","title":"enum MotorId"},{"location":"api/namespacerb/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"api/namespacerb/#variable-stupidservoscount","text":"1 constexpr int rb :: StupidServosCount ;","title":"variable StupidServosCount"},{"location":"api/namespacerb/#variable-ultrasoundscount","text":"1 constexpr int rb :: UltrasoundsCount ;","title":"variable UltrasoundsCount"},{"location":"api/namespacerb/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/namespacerb/#function-clamp","text":"1 2 3 4 5 6 template < typename T typename T > T rb :: clamp ( T value , T min , T max )","title":"function clamp"},{"location":"api/namespacerb/#function-delay","text":"1 2 3 inline void rb :: delay ( std :: chrono :: duration < uint32_t , std :: milli > delay )","title":"function delay"},{"location":"api/namespacerb/#function-delayms","text":"1 2 3 inline void rb :: delayMs ( int ms )","title":"function delayMs"},{"location":"api/namespacerb/#function-operator_deg","text":"1 2 3 Angle rb :: operator \"\" _deg ( long double d )","title":"function operator\"\"_deg"},{"location":"api/namespacerb/#function-operator_deg_1","text":"1 2 3 Angle rb :: operator \"\" _deg ( unsigned long long int d )","title":"function operator\"\"_deg"},{"location":"api/namespacerb/#function-operator_rad","text":"1 2 3 Angle rb :: operator \"\" _rad ( long double r )","title":"function operator\"\"_rad"},{"location":"api/namespacerb/#function-operator_rad_1","text":"1 2 3 Angle rb :: operator \"\" _rad ( unsigned long long int r )","title":"function operator\"\"_rad"},{"location":"api/namespacerb/#function-operator","text":"1 2 3 4 Angle rb :: operator * ( Angle a , Angle :: _T c )","title":"function operator*"},{"location":"api/namespacerb/#function-operator_1","text":"1 2 3 4 Angle rb :: operator + ( Angle a , Angle b )","title":"function operator+"},{"location":"api/namespacerb/#function-operator_2","text":"1 2 3 inline MotorId rb :: operator ++ ( MotorId & x )","title":"function operator++"},{"location":"api/namespacerb/#function-operator-","text":"1 2 3 4 Angle rb :: operator - ( Angle a , Angle b )","title":"function operator-"},{"location":"api/namespacerb/#function-operator_3","text":"1 2 3 4 Angle rb :: operator / ( Angle a , Angle :: _T c )","title":"function operator/"},{"location":"api/namespacerb/#function-operator_4","text":"1 2 3 4 inline ManagerInstallFlags rb :: operator | ( ManagerInstallFlags a , ManagerInstallFlags b )","title":"function operator|"},{"location":"api/namespacerb/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"api/namespacerb/#function-dietimers","text":"1 2 3 static void rb :: dieTimers ( TimerHandle_t timer ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXAngle.cpp","title":"function dieTimers"},{"location":"api/classrb_1_1Angle/","text":"Class rb::Angle Class List > rb > Angle Public Types Type Name typedef float _T Public Static Attributes Type Name const Angle Pi = = Angle::rad(Angle::_T(M_PI)) Public Functions Type Name Angle () _T deg () const bool isNaN () const Angle & operator*= (_T c) Angle & operator+= ( Angle a) Angle operator- () const Angle & operator-= ( Angle a) Angle & operator/= (_T c) _T rad () const Public Static Functions Type Name Angle deg (_T d) Angle nan () Angle rad (_T r) Public Types Documentation typedef _T 1 typedef float rb :: Angle :: _T ; Public Static Attributes Documentation variable Pi 1 const Angle rb :: Angle :: Pi ; Public Functions Documentation function Angle [1/2] 1 inline rb :: Angle :: Angle () function deg [1/2] 1 inline _T rb :: Angle :: deg () const function isNaN 1 inline bool rb :: Angle :: isNaN () const function operator*= 1 2 3 inline Angle & rb :: Angle :: operator *= ( _T c ) function operator+= 1 2 3 inline Angle & rb :: Angle :: operator += ( Angle a ) function operator- 1 inline Angle rb :: Angle :: operator - () const function operator-= 1 2 3 inline Angle & rb :: Angle :: operator -= ( Angle a ) function operator/= 1 2 3 inline Angle & rb :: Angle :: operator /= ( _T c ) function rad [1/2] 1 inline _T rb :: Angle :: rad () const Public Static Functions Documentation function deg [2/2] 1 2 3 static inline Angle rb :: Angle :: deg ( _T d ) function nan 1 static inline Angle rb :: Angle :: nan () function rad [2/2] 1 2 3 static inline Angle rb :: Angle :: rad ( _T r ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXAngle.h","title":"Class rb::Angle"},{"location":"api/classrb_1_1Angle/#class-rbangle","text":"Class List > rb > Angle","title":"Class rb::Angle"},{"location":"api/classrb_1_1Angle/#public-types","text":"Type Name typedef float _T","title":"Public Types"},{"location":"api/classrb_1_1Angle/#public-static-attributes","text":"Type Name const Angle Pi = = Angle::rad(Angle::_T(M_PI))","title":"Public Static Attributes"},{"location":"api/classrb_1_1Angle/#public-functions","text":"Type Name Angle () _T deg () const bool isNaN () const Angle & operator*= (_T c) Angle & operator+= ( Angle a) Angle operator- () const Angle & operator-= ( Angle a) Angle & operator/= (_T c) _T rad () const","title":"Public Functions"},{"location":"api/classrb_1_1Angle/#public-static-functions","text":"Type Name Angle deg (_T d) Angle nan () Angle rad (_T r)","title":"Public Static Functions"},{"location":"api/classrb_1_1Angle/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/classrb_1_1Angle/#typedef-_t","text":"1 typedef float rb :: Angle :: _T ;","title":"typedef _T"},{"location":"api/classrb_1_1Angle/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"api/classrb_1_1Angle/#variable-pi","text":"1 const Angle rb :: Angle :: Pi ;","title":"variable Pi"},{"location":"api/classrb_1_1Angle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1Angle/#function-angle-12","text":"1 inline rb :: Angle :: Angle ()","title":"function Angle [1/2]"},{"location":"api/classrb_1_1Angle/#function-deg-12","text":"1 inline _T rb :: Angle :: deg () const","title":"function deg [1/2]"},{"location":"api/classrb_1_1Angle/#function-isnan","text":"1 inline bool rb :: Angle :: isNaN () const","title":"function isNaN"},{"location":"api/classrb_1_1Angle/#function-operator","text":"1 2 3 inline Angle & rb :: Angle :: operator *= ( _T c )","title":"function operator*="},{"location":"api/classrb_1_1Angle/#function-operator_1","text":"1 2 3 inline Angle & rb :: Angle :: operator += ( Angle a )","title":"function operator+="},{"location":"api/classrb_1_1Angle/#function-operator-","text":"1 inline Angle rb :: Angle :: operator - () const","title":"function operator-"},{"location":"api/classrb_1_1Angle/#function-operator-_1","text":"1 2 3 inline Angle & rb :: Angle :: operator -= ( Angle a )","title":"function operator-="},{"location":"api/classrb_1_1Angle/#function-operator_2","text":"1 2 3 inline Angle & rb :: Angle :: operator /= ( _T c )","title":"function operator/="},{"location":"api/classrb_1_1Angle/#function-rad-12","text":"1 inline _T rb :: Angle :: rad () const","title":"function rad [1/2]"},{"location":"api/classrb_1_1Angle/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"api/classrb_1_1Angle/#function-deg-22","text":"1 2 3 static inline Angle rb :: Angle :: deg ( _T d )","title":"function deg [2/2]"},{"location":"api/classrb_1_1Angle/#function-nan","text":"1 static inline Angle rb :: Angle :: nan ()","title":"function nan"},{"location":"api/classrb_1_1Angle/#function-rad-22","text":"1 2 3 static inline Angle rb :: Angle :: rad ( _T r ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXAngle.h","title":"function rad [2/2]"},{"location":"api/classrb_1_1Battery/","text":"Class rb::Battery Class List > rb > Battery Contains the battery state and can control the robot's power. #include <RBCXBattery.h> Public Static Attributes Type Name constexpr uint32_t BATTERY_IN_THRESHOLD = = 5000 constexpr uint32_t VOLTAGE_MAX = = 4200 * 2 Maximal battery voltage, in mV. constexpr uint32_t VOLTAGE_MIN = = 3300 * 2 Minimal battery voltage, in mV, at which the robot shuts down. Public Functions Type Name bool isPoweredByBattery () const uint32_t pct () const returns current battery voltage void shutdown () shuts the robot's battery power int32_t temperatureC () const Public Static Attributes Documentation variable BATTERY_IN_THRESHOLD 1 constexpr uint32_t rb :: Battery :: BATTERY_IN_THRESHOLD ; variable VOLTAGE_MAX 1 constexpr uint32_t rb :: Battery :: VOLTAGE_MAX ; variable VOLTAGE_MIN 1 constexpr uint32_t rb :: Battery :: VOLTAGE_MIN ; Public Functions Documentation function isPoweredByBattery 1 inline bool rb :: Battery :: isPoweredByBattery () const function pct 1 uint32_t rb :: Battery :: pct () const function shutdown 1 void rb :: Battery :: shutdown () function temperatureC 1 inline int32_t rb :: Battery :: temperatureC () const The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXBattery.h","title":"Class rb::Battery"},{"location":"api/classrb_1_1Battery/#class-rbbattery","text":"Class List > rb > Battery Contains the battery state and can control the robot's power. #include <RBCXBattery.h>","title":"Class rb::Battery"},{"location":"api/classrb_1_1Battery/#public-static-attributes","text":"Type Name constexpr uint32_t BATTERY_IN_THRESHOLD = = 5000 constexpr uint32_t VOLTAGE_MAX = = 4200 * 2 Maximal battery voltage, in mV. constexpr uint32_t VOLTAGE_MIN = = 3300 * 2 Minimal battery voltage, in mV, at which the robot shuts down.","title":"Public Static Attributes"},{"location":"api/classrb_1_1Battery/#public-functions","text":"Type Name bool isPoweredByBattery () const uint32_t pct () const returns current battery voltage void shutdown () shuts the robot's battery power int32_t temperatureC () const","title":"Public Functions"},{"location":"api/classrb_1_1Battery/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"api/classrb_1_1Battery/#variable-battery_in_threshold","text":"1 constexpr uint32_t rb :: Battery :: BATTERY_IN_THRESHOLD ;","title":"variable BATTERY_IN_THRESHOLD"},{"location":"api/classrb_1_1Battery/#variable-voltage_max","text":"1 constexpr uint32_t rb :: Battery :: VOLTAGE_MAX ;","title":"variable VOLTAGE_MAX"},{"location":"api/classrb_1_1Battery/#variable-voltage_min","text":"1 constexpr uint32_t rb :: Battery :: VOLTAGE_MIN ;","title":"variable VOLTAGE_MIN"},{"location":"api/classrb_1_1Battery/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1Battery/#function-ispoweredbybattery","text":"1 inline bool rb :: Battery :: isPoweredByBattery () const","title":"function isPoweredByBattery"},{"location":"api/classrb_1_1Battery/#function-pct","text":"1 uint32_t rb :: Battery :: pct () const","title":"function pct"},{"location":"api/classrb_1_1Battery/#function-shutdown","text":"1 void rb :: Battery :: shutdown ()","title":"function shutdown"},{"location":"api/classrb_1_1Battery/#function-temperaturec","text":"1 inline int32_t rb :: Battery :: temperatureC () const The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXBattery.h","title":"function temperatureC"},{"location":"api/classrb_1_1Buttons/","text":"Class rb::Buttons Class List > rb > Buttons Public Types Type Name typedef std::function< bool(ButtonId, bool)> callback_t Public Static Attributes Type Name constexpr uint32_t Count = = 6 Public Functions Type Name bool byId (ButtonId id) const bool down () const bool left () const bool off () const bool on () const void onChange (callback_t callback) bool right () const bool up () const Public Types Documentation typedef callback_t 1 typedef std :: function < bool ( ButtonId , bool ) > rb :: Buttons :: callback_t ; Public Static Attributes Documentation variable Count 1 constexpr uint32_t rb :: Buttons :: Count ; Public Functions Documentation function byId 1 2 3 inline bool rb :: Buttons :: byId ( ButtonId id ) const function down 1 inline bool rb :: Buttons :: down () const function left 1 inline bool rb :: Buttons :: left () const function off 1 inline bool rb :: Buttons :: off () const function on 1 inline bool rb :: Buttons :: on () const function onChange 1 2 3 void rb :: Buttons :: onChange ( callback_t callback ) function right 1 inline bool rb :: Buttons :: right () const function up 1 inline bool rb :: Buttons :: up () const The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXButtons.h","title":"Class rb::Buttons"},{"location":"api/classrb_1_1Buttons/#class-rbbuttons","text":"Class List > rb > Buttons","title":"Class rb::Buttons"},{"location":"api/classrb_1_1Buttons/#public-types","text":"Type Name typedef std::function< bool(ButtonId, bool)> callback_t","title":"Public Types"},{"location":"api/classrb_1_1Buttons/#public-static-attributes","text":"Type Name constexpr uint32_t Count = = 6","title":"Public Static Attributes"},{"location":"api/classrb_1_1Buttons/#public-functions","text":"Type Name bool byId (ButtonId id) const bool down () const bool left () const bool off () const bool on () const void onChange (callback_t callback) bool right () const bool up () const","title":"Public Functions"},{"location":"api/classrb_1_1Buttons/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/classrb_1_1Buttons/#typedef-callback_t","text":"1 typedef std :: function < bool ( ButtonId , bool ) > rb :: Buttons :: callback_t ;","title":"typedef callback_t"},{"location":"api/classrb_1_1Buttons/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"api/classrb_1_1Buttons/#variable-count","text":"1 constexpr uint32_t rb :: Buttons :: Count ;","title":"variable Count"},{"location":"api/classrb_1_1Buttons/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1Buttons/#function-byid","text":"1 2 3 inline bool rb :: Buttons :: byId ( ButtonId id ) const","title":"function byId"},{"location":"api/classrb_1_1Buttons/#function-down","text":"1 inline bool rb :: Buttons :: down () const","title":"function down"},{"location":"api/classrb_1_1Buttons/#function-left","text":"1 inline bool rb :: Buttons :: left () const","title":"function left"},{"location":"api/classrb_1_1Buttons/#function-off","text":"1 inline bool rb :: Buttons :: off () const","title":"function off"},{"location":"api/classrb_1_1Buttons/#function-on","text":"1 inline bool rb :: Buttons :: on () const","title":"function on"},{"location":"api/classrb_1_1Buttons/#function-onchange","text":"1 2 3 void rb :: Buttons :: onChange ( callback_t callback )","title":"function onChange"},{"location":"api/classrb_1_1Buttons/#function-right","text":"1 inline bool rb :: Buttons :: right () const","title":"function right"},{"location":"api/classrb_1_1Buttons/#function-up","text":"1 inline bool rb :: Buttons :: up () const The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXButtons.h","title":"function up"},{"location":"api/classrb_1_1Leds/","text":"Class rb::Leds Class List > rb > Leds Public Functions Type Name void blue (bool on=true) Set the blue LED state. void byId (LedId id, bool on=true) Set led styte by LedId. void green (bool on=true) Set the green LED state. void red (bool on=true) Set the red LED state. void yellow (bool on=true) Set the yellow LED state. Public Functions Documentation function blue 1 2 3 void rb :: Leds :: blue ( bool on = true ) function byId 1 2 3 4 void rb :: Leds :: byId ( LedId id , bool on = true ) function green 1 2 3 void rb :: Leds :: green ( bool on = true ) function red 1 2 3 void rb :: Leds :: red ( bool on = true ) function yellow 1 2 3 void rb :: Leds :: yellow ( bool on = true ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXLeds.h","title":"Class rb::Leds"},{"location":"api/classrb_1_1Leds/#class-rbleds","text":"Class List > rb > Leds","title":"Class rb::Leds"},{"location":"api/classrb_1_1Leds/#public-functions","text":"Type Name void blue (bool on=true) Set the blue LED state. void byId (LedId id, bool on=true) Set led styte by LedId. void green (bool on=true) Set the green LED state. void red (bool on=true) Set the red LED state. void yellow (bool on=true) Set the yellow LED state.","title":"Public Functions"},{"location":"api/classrb_1_1Leds/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1Leds/#function-blue","text":"1 2 3 void rb :: Leds :: blue ( bool on = true )","title":"function blue"},{"location":"api/classrb_1_1Leds/#function-byid","text":"1 2 3 4 void rb :: Leds :: byId ( LedId id , bool on = true )","title":"function byId"},{"location":"api/classrb_1_1Leds/#function-green","text":"1 2 3 void rb :: Leds :: green ( bool on = true )","title":"function green"},{"location":"api/classrb_1_1Leds/#function-red","text":"1 2 3 void rb :: Leds :: red ( bool on = true )","title":"function red"},{"location":"api/classrb_1_1Leds/#function-yellow","text":"1 2 3 void rb :: Leds :: yellow ( bool on = true ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXLeds.h","title":"function yellow"},{"location":"api/classrb_1_1Manager/","text":"Class rb::Manager Class List > rb > Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. #include <RBCXManager.h> Public Functions Type Name Manager ( Manager const &) = delete Buttons & buttons () const CoprocStat_VersionStat & coprocFwVersion () const void coprocFwVersionAssert (uint32_t minVersion, const char * name) void install (ManagerInstallFlags flags=MAN_NONE, BaseType_t managerLoopStackSize=3072) Initialize the manager - must be called once at the start of the program. void monitorTask (TaskHandle_t task) Motor & motor (MotorId id) void operator= ( Manager const &) = delete void schedule (uint32_t period_ms, std::function< bool()> callback) Schedule callback to fire after period (in millisecond). void sendToCoproc (const CoprocReq & msg) MotorChangeBuilder setMotors () Get a motor instance. StupidServo & stupidServo (uint8_t index) Timers & timers () Ultrasound & ultrasound (uint8_t index) Initialize the UART servo bus for intelligent servos LX-16. TODO: smart servos not implemented! Public Static Functions Type Name Manager & get () Get manager instance. Public Functions Documentation function Manager [2/2] 1 2 3 rb :: Manager :: Manager ( Manager const & ) = delete function buttons 1 inline Buttons & rb :: Manager :: buttons () function coprocFwVersion 1 inline const CoprocStat_VersionStat & rb :: Manager :: coprocFwVersion () const function coprocFwVersionAssert 1 2 3 4 void rb :: Manager :: coprocFwVersionAssert ( uint32_t minVersion , const char * name ) function install 1 2 3 4 void rb :: Manager :: install ( ManagerInstallFlags flags = MAN_NONE , BaseType_t managerLoopStackSize = 3072 ) function monitorTask 1 2 3 void rb :: Manager :: monitorTask ( TaskHandle_t task ) function motor 1 2 3 inline Motor & rb :: Manager :: motor ( MotorId id ) function operator= 1 2 3 void rb :: Manager :: operator = ( Manager const & ) = delete function schedule 1 2 3 4 inline void rb :: Manager :: schedule ( uint32_t period_ms , std :: function < bool () > callback ) function sendToCoproc 1 2 3 void rb :: Manager :: sendToCoproc ( const CoprocReq & msg ) function setMotors 1 MotorChangeBuilder rb :: Manager :: setMotors () function stupidServo 1 2 3 inline StupidServo & rb :: Manager :: stupidServo ( uint8_t index ) function timers 1 inline Timers & rb :: Manager :: timers () function ultrasound 1 2 3 inline Ultrasound & rb :: Manager :: ultrasound ( uint8_t index ) Public Static Functions Documentation function get 1 static inline Manager & rb :: Manager :: get () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXManager.h","title":"Class rb::Manager"},{"location":"api/classrb_1_1Manager/#class-rbmanager","text":"Class List > rb > Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. #include <RBCXManager.h>","title":"Class rb::Manager"},{"location":"api/classrb_1_1Manager/#public-functions","text":"Type Name Manager ( Manager const &) = delete Buttons & buttons () const CoprocStat_VersionStat & coprocFwVersion () const void coprocFwVersionAssert (uint32_t minVersion, const char * name) void install (ManagerInstallFlags flags=MAN_NONE, BaseType_t managerLoopStackSize=3072) Initialize the manager - must be called once at the start of the program. void monitorTask (TaskHandle_t task) Motor & motor (MotorId id) void operator= ( Manager const &) = delete void schedule (uint32_t period_ms, std::function< bool()> callback) Schedule callback to fire after period (in millisecond). void sendToCoproc (const CoprocReq & msg) MotorChangeBuilder setMotors () Get a motor instance. StupidServo & stupidServo (uint8_t index) Timers & timers () Ultrasound & ultrasound (uint8_t index) Initialize the UART servo bus for intelligent servos LX-16. TODO: smart servos not implemented!","title":"Public Functions"},{"location":"api/classrb_1_1Manager/#public-static-functions","text":"Type Name Manager & get () Get manager instance.","title":"Public Static Functions"},{"location":"api/classrb_1_1Manager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1Manager/#function-manager-22","text":"1 2 3 rb :: Manager :: Manager ( Manager const & ) = delete","title":"function Manager [2/2]"},{"location":"api/classrb_1_1Manager/#function-buttons","text":"1 inline Buttons & rb :: Manager :: buttons ()","title":"function buttons"},{"location":"api/classrb_1_1Manager/#function-coprocfwversion","text":"1 inline const CoprocStat_VersionStat & rb :: Manager :: coprocFwVersion () const","title":"function coprocFwVersion"},{"location":"api/classrb_1_1Manager/#function-coprocfwversionassert","text":"1 2 3 4 void rb :: Manager :: coprocFwVersionAssert ( uint32_t minVersion , const char * name )","title":"function coprocFwVersionAssert"},{"location":"api/classrb_1_1Manager/#function-install","text":"1 2 3 4 void rb :: Manager :: install ( ManagerInstallFlags flags = MAN_NONE , BaseType_t managerLoopStackSize = 3072 )","title":"function install"},{"location":"api/classrb_1_1Manager/#function-monitortask","text":"1 2 3 void rb :: Manager :: monitorTask ( TaskHandle_t task )","title":"function monitorTask"},{"location":"api/classrb_1_1Manager/#function-motor","text":"1 2 3 inline Motor & rb :: Manager :: motor ( MotorId id )","title":"function motor"},{"location":"api/classrb_1_1Manager/#function-operator","text":"1 2 3 void rb :: Manager :: operator = ( Manager const & ) = delete","title":"function operator="},{"location":"api/classrb_1_1Manager/#function-schedule","text":"1 2 3 4 inline void rb :: Manager :: schedule ( uint32_t period_ms , std :: function < bool () > callback )","title":"function schedule"},{"location":"api/classrb_1_1Manager/#function-sendtocoproc","text":"1 2 3 void rb :: Manager :: sendToCoproc ( const CoprocReq & msg )","title":"function sendToCoproc"},{"location":"api/classrb_1_1Manager/#function-setmotors","text":"1 MotorChangeBuilder rb :: Manager :: setMotors ()","title":"function setMotors"},{"location":"api/classrb_1_1Manager/#function-stupidservo","text":"1 2 3 inline StupidServo & rb :: Manager :: stupidServo ( uint8_t index )","title":"function stupidServo"},{"location":"api/classrb_1_1Manager/#function-timers","text":"1 inline Timers & rb :: Manager :: timers ()","title":"function timers"},{"location":"api/classrb_1_1Manager/#function-ultrasound","text":"1 2 3 inline Ultrasound & rb :: Manager :: ultrasound ( uint8_t index )","title":"function ultrasound"},{"location":"api/classrb_1_1Manager/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"api/classrb_1_1Manager/#function-get","text":"1 static inline Manager & rb :: Manager :: get () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXManager.h","title":"function get"},{"location":"api/classrb_1_1Motor/","text":"Class rb::Motor Class List > rb > Motor Public Types Type Name typedef std::function< void( Motor &)> callback_t Public Functions Type Name void brake (uint16_t brakingPower) Start braking. void drive (int32_t positionRelative, int16_t speedTicksPerSecond, callback_t callback=nullptr) Drive motor to set position (according relative value). void driveToValue (int32_t positionAbsolute, int16_t speedTicksPerSecond, callback_t callback=nullptr) Drive motor to set position (according absolute value). MotorId id () const int32_t position () const void power (int16_t value) Set motor power. void pwmMaxPercent (int8_t percent) Limit the maximum PWM value. If you call pwmMaxPercent(70) and then power(100), the motors will spin at 70% of maximum speed. This scales both the power and speed set through Motor . int8_t pwmMaxPercent () const Get current maximum PWM percent value. void requestInfo (callback_t cb) void setConfig (const MotorConfig & cfg) Set configuration, see MotorConfig & STM32 firmware. void setCurrentPosition (int32_t pos=0) Set the encoder tick counter to some value. void speed (int16_t ticksPerSecond) Set motor speed. Public Types Documentation typedef callback_t 1 typedef std :: function < void ( Motor & ) > rb :: Motor :: callback_t ; Public Functions Documentation function brake 1 2 3 void rb :: Motor :: brake ( uint16_t brakingPower ) function drive 1 2 3 4 5 void rb :: Motor :: drive ( int32_t positionRelative , int16_t speedTicksPerSecond , callback_t callback = nullptr ) function driveToValue 1 2 3 4 5 void rb :: Motor :: driveToValue ( int32_t positionAbsolute , int16_t speedTicksPerSecond , callback_t callback = nullptr ) function id 1 inline MotorId rb :: Motor :: id () const function position 1 inline int32_t rb :: Motor :: position () const function power 1 2 3 void rb :: Motor :: power ( int16_t value ) function pwmMaxPercent [1/2] 1 2 3 void rb :: Motor :: pwmMaxPercent ( int8_t percent ) function pwmMaxPercent [2/2] 1 inline int8_t rb :: Motor :: pwmMaxPercent () const function requestInfo 1 2 3 void rb :: Motor :: requestInfo ( callback_t cb ) function setConfig 1 2 3 void rb :: Motor :: setConfig ( const MotorConfig & cfg ) function setCurrentPosition 1 2 3 void rb :: Motor :: setCurrentPosition ( int32_t pos = 0 ) function speed 1 2 3 void rb :: Motor :: speed ( int16_t ticksPerSecond ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXMotor.h","title":"Class rb::Motor"},{"location":"api/classrb_1_1Motor/#class-rbmotor","text":"Class List > rb > Motor","title":"Class rb::Motor"},{"location":"api/classrb_1_1Motor/#public-types","text":"Type Name typedef std::function< void( Motor &)> callback_t","title":"Public Types"},{"location":"api/classrb_1_1Motor/#public-functions","text":"Type Name void brake (uint16_t brakingPower) Start braking. void drive (int32_t positionRelative, int16_t speedTicksPerSecond, callback_t callback=nullptr) Drive motor to set position (according relative value). void driveToValue (int32_t positionAbsolute, int16_t speedTicksPerSecond, callback_t callback=nullptr) Drive motor to set position (according absolute value). MotorId id () const int32_t position () const void power (int16_t value) Set motor power. void pwmMaxPercent (int8_t percent) Limit the maximum PWM value. If you call pwmMaxPercent(70) and then power(100), the motors will spin at 70% of maximum speed. This scales both the power and speed set through Motor . int8_t pwmMaxPercent () const Get current maximum PWM percent value. void requestInfo (callback_t cb) void setConfig (const MotorConfig & cfg) Set configuration, see MotorConfig & STM32 firmware. void setCurrentPosition (int32_t pos=0) Set the encoder tick counter to some value. void speed (int16_t ticksPerSecond) Set motor speed.","title":"Public Functions"},{"location":"api/classrb_1_1Motor/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/classrb_1_1Motor/#typedef-callback_t","text":"1 typedef std :: function < void ( Motor & ) > rb :: Motor :: callback_t ;","title":"typedef callback_t"},{"location":"api/classrb_1_1Motor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1Motor/#function-brake","text":"1 2 3 void rb :: Motor :: brake ( uint16_t brakingPower )","title":"function brake"},{"location":"api/classrb_1_1Motor/#function-drive","text":"1 2 3 4 5 void rb :: Motor :: drive ( int32_t positionRelative , int16_t speedTicksPerSecond , callback_t callback = nullptr )","title":"function drive"},{"location":"api/classrb_1_1Motor/#function-drivetovalue","text":"1 2 3 4 5 void rb :: Motor :: driveToValue ( int32_t positionAbsolute , int16_t speedTicksPerSecond , callback_t callback = nullptr )","title":"function driveToValue"},{"location":"api/classrb_1_1Motor/#function-id","text":"1 inline MotorId rb :: Motor :: id () const","title":"function id"},{"location":"api/classrb_1_1Motor/#function-position","text":"1 inline int32_t rb :: Motor :: position () const","title":"function position"},{"location":"api/classrb_1_1Motor/#function-power","text":"1 2 3 void rb :: Motor :: power ( int16_t value )","title":"function power"},{"location":"api/classrb_1_1Motor/#function-pwmmaxpercent-12","text":"1 2 3 void rb :: Motor :: pwmMaxPercent ( int8_t percent )","title":"function pwmMaxPercent [1/2]"},{"location":"api/classrb_1_1Motor/#function-pwmmaxpercent-22","text":"1 inline int8_t rb :: Motor :: pwmMaxPercent () const","title":"function pwmMaxPercent [2/2]"},{"location":"api/classrb_1_1Motor/#function-requestinfo","text":"1 2 3 void rb :: Motor :: requestInfo ( callback_t cb )","title":"function requestInfo"},{"location":"api/classrb_1_1Motor/#function-setconfig","text":"1 2 3 void rb :: Motor :: setConfig ( const MotorConfig & cfg )","title":"function setConfig"},{"location":"api/classrb_1_1Motor/#function-setcurrentposition","text":"1 2 3 void rb :: Motor :: setCurrentPosition ( int32_t pos = 0 )","title":"function setCurrentPosition"},{"location":"api/classrb_1_1Motor/#function-speed","text":"1 2 3 void rb :: Motor :: speed ( int16_t ticksPerSecond ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXMotor.h","title":"function speed"},{"location":"api/classrb_1_1MotorChangeBuilder/","text":"Class rb::MotorChangeBuilder Class List > rb > MotorChangeBuilder Helper class for building the motor change event. #include <RBCXManager.h> Public Functions Type Name MotorChangeBuilder () MotorChangeBuilder (const MotorChangeBuilder & o) = delete MotorChangeBuilder ( MotorChangeBuilder && o) MotorChangeBuilder & brake (MotorId id, uint16_t brakingPower) Start braking. MotorChangeBuilder & drive (MotorId id, int32_t positionRelative, int16_t speedTicksPerSecond, Motor::callback_t callback=nullptr) MotorChangeBuilder & driveToValue (MotorId id, int32_t positionAbsolute, int16_t speedTicksPerSecond, Motor::callback_t callback=nullptr) MotorChangeBuilder & power (MotorId id, int16_t value) Set single motor power. MotorChangeBuilder & pwmMaxPercent (MotorId id, int8_t percent) Limit motor index's power to percent. void set () Finish the changes and submit the events. MotorChangeBuilder & speed (MotorId id, int16_t ticksPerSecond) Set single motor power. ~MotorChangeBuilder () Public Functions Documentation function MotorChangeBuilder [1/3] 1 rb :: MotorChangeBuilder :: MotorChangeBuilder () function MotorChangeBuilder [2/3] 1 2 3 rb :: MotorChangeBuilder :: MotorChangeBuilder ( const MotorChangeBuilder & o ) = delete function MotorChangeBuilder [3/3] 1 2 3 rb :: MotorChangeBuilder :: MotorChangeBuilder ( MotorChangeBuilder && o ) function brake 1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: brake ( MotorId id , uint16_t brakingPower ) function drive 1 2 3 4 5 6 MotorChangeBuilder & rb :: MotorChangeBuilder :: drive ( MotorId id , int32_t positionRelative , int16_t speedTicksPerSecond , Motor :: callback_t callback = nullptr ) function driveToValue 1 2 3 4 5 6 MotorChangeBuilder & rb :: MotorChangeBuilder :: driveToValue ( MotorId id , int32_t positionAbsolute , int16_t speedTicksPerSecond , Motor :: callback_t callback = nullptr ) function power 1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: power ( MotorId id , int16_t value ) function pwmMaxPercent 1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: pwmMaxPercent ( MotorId id , int8_t percent ) function set 1 void rb :: MotorChangeBuilder :: set () function speed 1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: speed ( MotorId id , int16_t ticksPerSecond ) function ~MotorChangeBuilder 1 rb :: MotorChangeBuilder ::~ MotorChangeBuilder () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXManager.h","title":"Class rb::MotorChangeBuilder"},{"location":"api/classrb_1_1MotorChangeBuilder/#class-rbmotorchangebuilder","text":"Class List > rb > MotorChangeBuilder Helper class for building the motor change event. #include <RBCXManager.h>","title":"Class rb::MotorChangeBuilder"},{"location":"api/classrb_1_1MotorChangeBuilder/#public-functions","text":"Type Name MotorChangeBuilder () MotorChangeBuilder (const MotorChangeBuilder & o) = delete MotorChangeBuilder ( MotorChangeBuilder && o) MotorChangeBuilder & brake (MotorId id, uint16_t brakingPower) Start braking. MotorChangeBuilder & drive (MotorId id, int32_t positionRelative, int16_t speedTicksPerSecond, Motor::callback_t callback=nullptr) MotorChangeBuilder & driveToValue (MotorId id, int32_t positionAbsolute, int16_t speedTicksPerSecond, Motor::callback_t callback=nullptr) MotorChangeBuilder & power (MotorId id, int16_t value) Set single motor power. MotorChangeBuilder & pwmMaxPercent (MotorId id, int8_t percent) Limit motor index's power to percent. void set () Finish the changes and submit the events. MotorChangeBuilder & speed (MotorId id, int16_t ticksPerSecond) Set single motor power. ~MotorChangeBuilder ()","title":"Public Functions"},{"location":"api/classrb_1_1MotorChangeBuilder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1MotorChangeBuilder/#function-motorchangebuilder-13","text":"1 rb :: MotorChangeBuilder :: MotorChangeBuilder ()","title":"function MotorChangeBuilder [1/3]"},{"location":"api/classrb_1_1MotorChangeBuilder/#function-motorchangebuilder-23","text":"1 2 3 rb :: MotorChangeBuilder :: MotorChangeBuilder ( const MotorChangeBuilder & o ) = delete","title":"function MotorChangeBuilder [2/3]"},{"location":"api/classrb_1_1MotorChangeBuilder/#function-motorchangebuilder-33","text":"1 2 3 rb :: MotorChangeBuilder :: MotorChangeBuilder ( MotorChangeBuilder && o )","title":"function MotorChangeBuilder [3/3]"},{"location":"api/classrb_1_1MotorChangeBuilder/#function-brake","text":"1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: brake ( MotorId id , uint16_t brakingPower )","title":"function brake"},{"location":"api/classrb_1_1MotorChangeBuilder/#function-drive","text":"1 2 3 4 5 6 MotorChangeBuilder & rb :: MotorChangeBuilder :: drive ( MotorId id , int32_t positionRelative , int16_t speedTicksPerSecond , Motor :: callback_t callback = nullptr )","title":"function drive"},{"location":"api/classrb_1_1MotorChangeBuilder/#function-drivetovalue","text":"1 2 3 4 5 6 MotorChangeBuilder & rb :: MotorChangeBuilder :: driveToValue ( MotorId id , int32_t positionAbsolute , int16_t speedTicksPerSecond , Motor :: callback_t callback = nullptr )","title":"function driveToValue"},{"location":"api/classrb_1_1MotorChangeBuilder/#function-power","text":"1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: power ( MotorId id , int16_t value )","title":"function power"},{"location":"api/classrb_1_1MotorChangeBuilder/#function-pwmmaxpercent","text":"1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: pwmMaxPercent ( MotorId id , int8_t percent )","title":"function pwmMaxPercent"},{"location":"api/classrb_1_1MotorChangeBuilder/#function-set","text":"1 void rb :: MotorChangeBuilder :: set ()","title":"function set"},{"location":"api/classrb_1_1MotorChangeBuilder/#function-speed","text":"1 2 3 4 MotorChangeBuilder & rb :: MotorChangeBuilder :: speed ( MotorId id , int16_t ticksPerSecond )","title":"function speed"},{"location":"api/classrb_1_1MotorChangeBuilder/#function-motorchangebuilder","text":"1 rb :: MotorChangeBuilder ::~ MotorChangeBuilder () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXManager.h","title":"function ~MotorChangeBuilder"},{"location":"api/classrb_1_1Nvs/","text":"Class rb::Nvs Class List > rb > Nvs Public Functions Type Name Nvs (const char * name_space, const char * partition=\"nvs\") Nvs (const Nvs &) = delete void commit () bool existsInt (const char * key) bool existsString (const char * key) int getInt (const char * key) std::string getString (const char * key) void writeInt (const char * key, int value) void writeString (const char * key, const std::string & value) ~Nvs () Public Functions Documentation function Nvs [1/2] 1 2 3 4 rb :: Nvs :: Nvs ( const char * name_space , const char * partition = \"nvs\" ) function Nvs [2/2] 1 2 3 rb :: Nvs :: Nvs ( const Nvs & ) = delete function commit 1 void rb :: Nvs :: commit () function existsInt 1 2 3 bool rb :: Nvs :: existsInt ( const char * key ) function existsString 1 2 3 bool rb :: Nvs :: existsString ( const char * key ) function getInt 1 2 3 int rb :: Nvs :: getInt ( const char * key ) function getString 1 2 3 std :: string rb :: Nvs :: getString ( const char * key ) function writeInt 1 2 3 4 void rb :: Nvs :: writeInt ( const char * key , int value ) function writeString 1 2 3 4 void rb :: Nvs :: writeString ( const char * key , const std :: string & value ) function ~Nvs 1 rb :: Nvs ::~ Nvs () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXNvs.h","title":"Class rb::Nvs"},{"location":"api/classrb_1_1Nvs/#class-rbnvs","text":"Class List > rb > Nvs","title":"Class rb::Nvs"},{"location":"api/classrb_1_1Nvs/#public-functions","text":"Type Name Nvs (const char * name_space, const char * partition=\"nvs\") Nvs (const Nvs &) = delete void commit () bool existsInt (const char * key) bool existsString (const char * key) int getInt (const char * key) std::string getString (const char * key) void writeInt (const char * key, int value) void writeString (const char * key, const std::string & value) ~Nvs ()","title":"Public Functions"},{"location":"api/classrb_1_1Nvs/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1Nvs/#function-nvs-12","text":"1 2 3 4 rb :: Nvs :: Nvs ( const char * name_space , const char * partition = \"nvs\" )","title":"function Nvs [1/2]"},{"location":"api/classrb_1_1Nvs/#function-nvs-22","text":"1 2 3 rb :: Nvs :: Nvs ( const Nvs & ) = delete","title":"function Nvs [2/2]"},{"location":"api/classrb_1_1Nvs/#function-commit","text":"1 void rb :: Nvs :: commit ()","title":"function commit"},{"location":"api/classrb_1_1Nvs/#function-existsint","text":"1 2 3 bool rb :: Nvs :: existsInt ( const char * key )","title":"function existsInt"},{"location":"api/classrb_1_1Nvs/#function-existsstring","text":"1 2 3 bool rb :: Nvs :: existsString ( const char * key )","title":"function existsString"},{"location":"api/classrb_1_1Nvs/#function-getint","text":"1 2 3 int rb :: Nvs :: getInt ( const char * key )","title":"function getInt"},{"location":"api/classrb_1_1Nvs/#function-getstring","text":"1 2 3 std :: string rb :: Nvs :: getString ( const char * key )","title":"function getString"},{"location":"api/classrb_1_1Nvs/#function-writeint","text":"1 2 3 4 void rb :: Nvs :: writeInt ( const char * key , int value )","title":"function writeInt"},{"location":"api/classrb_1_1Nvs/#function-writestring","text":"1 2 3 4 void rb :: Nvs :: writeString ( const char * key , const std :: string & value )","title":"function writeString"},{"location":"api/classrb_1_1Nvs/#function-nvs","text":"1 rb :: Nvs ::~ Nvs () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXNvs.h","title":"function ~Nvs"},{"location":"api/classrb_1_1Piezo/","text":"Class rb::Piezo Class List > rb > Piezo Helper class for controlling the piezo. #include <RBCXPiezo.h> Public Functions Type Name void setState (bool on) void start () void stop () Public Functions Documentation function setState 1 2 3 void rb :: Piezo :: setState ( bool on ) function start 1 inline void rb :: Piezo :: start () function stop 1 inline void rb :: Piezo :: stop () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXPiezo.h","title":"Class rb::Piezo"},{"location":"api/classrb_1_1Piezo/#class-rbpiezo","text":"Class List > rb > Piezo Helper class for controlling the piezo. #include <RBCXPiezo.h>","title":"Class rb::Piezo"},{"location":"api/classrb_1_1Piezo/#public-functions","text":"Type Name void setState (bool on) void start () void stop ()","title":"Public Functions"},{"location":"api/classrb_1_1Piezo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1Piezo/#function-setstate","text":"1 2 3 void rb :: Piezo :: setState ( bool on )","title":"function setState"},{"location":"api/classrb_1_1Piezo/#function-start","text":"1 inline void rb :: Piezo :: start ()","title":"function start"},{"location":"api/classrb_1_1Piezo/#function-stop","text":"1 inline void rb :: Piezo :: stop () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXPiezo.h","title":"function stop"},{"location":"api/classrb_1_1SmartServoBus/","text":"Class rb::SmartServoBus Class List > rb > SmartServoBus Public Functions Type Name SmartServoBus () uint8_t getId (uint8_t destId=254) void limit (uint8_t id, Angle bottom, Angle top) Angle pos (uint8_t id) Angle posOffline (uint8_t id) void set (uint8_t id, Angle ang, float speed=180.f, float speed_raise=0.0015f) void setAutoStop (uint8_t id, bool enable=true) void setId (uint8_t newId, uint8_t destId=254) ~SmartServoBus () Public Functions Documentation function SmartServoBus [1/2] 1 rb :: SmartServoBus :: SmartServoBus () function getId 1 2 3 uint8_t rb :: SmartServoBus :: getId ( uint8_t destId = 254 ) function limit 1 2 3 4 5 void rb :: SmartServoBus :: limit ( uint8_t id , Angle bottom , Angle top ) function pos 1 2 3 Angle rb :: SmartServoBus :: pos ( uint8_t id ) function posOffline 1 2 3 Angle rb :: SmartServoBus :: posOffline ( uint8_t id ) function set 1 2 3 4 5 6 void rb :: SmartServoBus :: set ( uint8_t id , Angle ang , float speed = 180.f , float speed_raise = 0.0015f ) function setAutoStop 1 2 3 4 void rb :: SmartServoBus :: setAutoStop ( uint8_t id , bool enable = true ) function setId 1 2 3 4 void rb :: SmartServoBus :: setId ( uint8_t newId , uint8_t destId = 254 ) function ~SmartServoBus 1 inline rb :: SmartServoBus ::~ SmartServoBus () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXSmartServo.h","title":"Class rb::SmartServoBus"},{"location":"api/classrb_1_1SmartServoBus/#class-rbsmartservobus","text":"Class List > rb > SmartServoBus","title":"Class rb::SmartServoBus"},{"location":"api/classrb_1_1SmartServoBus/#public-functions","text":"Type Name SmartServoBus () uint8_t getId (uint8_t destId=254) void limit (uint8_t id, Angle bottom, Angle top) Angle pos (uint8_t id) Angle posOffline (uint8_t id) void set (uint8_t id, Angle ang, float speed=180.f, float speed_raise=0.0015f) void setAutoStop (uint8_t id, bool enable=true) void setId (uint8_t newId, uint8_t destId=254) ~SmartServoBus ()","title":"Public Functions"},{"location":"api/classrb_1_1SmartServoBus/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1SmartServoBus/#function-smartservobus-12","text":"1 rb :: SmartServoBus :: SmartServoBus ()","title":"function SmartServoBus [1/2]"},{"location":"api/classrb_1_1SmartServoBus/#function-getid","text":"1 2 3 uint8_t rb :: SmartServoBus :: getId ( uint8_t destId = 254 )","title":"function getId"},{"location":"api/classrb_1_1SmartServoBus/#function-limit","text":"1 2 3 4 5 void rb :: SmartServoBus :: limit ( uint8_t id , Angle bottom , Angle top )","title":"function limit"},{"location":"api/classrb_1_1SmartServoBus/#function-pos","text":"1 2 3 Angle rb :: SmartServoBus :: pos ( uint8_t id )","title":"function pos"},{"location":"api/classrb_1_1SmartServoBus/#function-posoffline","text":"1 2 3 Angle rb :: SmartServoBus :: posOffline ( uint8_t id )","title":"function posOffline"},{"location":"api/classrb_1_1SmartServoBus/#function-set","text":"1 2 3 4 5 6 void rb :: SmartServoBus :: set ( uint8_t id , Angle ang , float speed = 180.f , float speed_raise = 0.0015f )","title":"function set"},{"location":"api/classrb_1_1SmartServoBus/#function-setautostop","text":"1 2 3 4 void rb :: SmartServoBus :: setAutoStop ( uint8_t id , bool enable = true )","title":"function setAutoStop"},{"location":"api/classrb_1_1SmartServoBus/#function-setid","text":"1 2 3 4 void rb :: SmartServoBus :: setId ( uint8_t newId , uint8_t destId = 254 )","title":"function setId"},{"location":"api/classrb_1_1SmartServoBus/#function-smartservobus","text":"1 inline rb :: SmartServoBus ::~ SmartServoBus () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXSmartServo.h","title":"function ~SmartServoBus"},{"location":"api/classrb_1_1StupidServo/","text":"Class rb::StupidServo Class List > rb > StupidServo Public Functions Type Name void disable () float position () const void setPosition (float positionFraction) Returns last set position (can be NaN if disabled) Public Functions Documentation function disable 1 void rb :: StupidServo :: disable () function position 1 inline float rb :: StupidServo :: position () const function setPosition 1 2 3 void rb :: StupidServo :: setPosition ( float positionFraction ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXStupidServo.h","title":"Class rb::StupidServo"},{"location":"api/classrb_1_1StupidServo/#class-rbstupidservo","text":"Class List > rb > StupidServo","title":"Class rb::StupidServo"},{"location":"api/classrb_1_1StupidServo/#public-functions","text":"Type Name void disable () float position () const void setPosition (float positionFraction) Returns last set position (can be NaN if disabled)","title":"Public Functions"},{"location":"api/classrb_1_1StupidServo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1StupidServo/#function-disable","text":"1 void rb :: StupidServo :: disable ()","title":"function disable"},{"location":"api/classrb_1_1StupidServo/#function-position","text":"1 inline float rb :: StupidServo :: position () const","title":"function position"},{"location":"api/classrb_1_1StupidServo/#function-setposition","text":"1 2 3 void rb :: StupidServo :: setPosition ( float positionFraction ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXStupidServo.h","title":"function setPosition"},{"location":"api/classrb_1_1Timers/","text":"Class rb::Timers Class List > rb > Timers Public Static Attributes Type Name constexpr uint16_t INVALID_ID = = 0 Public Functions Type Name bool cancel (uint16_t id) bool isOnTimerTask () const bool reset (uint16_t id, uint32_t period_ms) uint16_t schedule (uint32_t period_ms, std::function< bool()> callback) Schedule callback to fire after period (in millisecond). bool stop (uint16_t id) Public Static Functions Type Name void deleteFreeRtOsTimerTask () If you don't plan to use FreeRTOS SW timers, call this to free up 2KB of heap. Timers & get () Public Static Attributes Documentation variable INVALID_ID 1 constexpr uint16_t rb :: Timers :: INVALID_ID ; Public Functions Documentation function cancel 1 2 3 bool rb :: Timers :: cancel ( uint16_t id ) function isOnTimerTask 1 bool rb :: Timers :: isOnTimerTask () const function reset 1 2 3 4 bool rb :: Timers :: reset ( uint16_t id , uint32_t period_ms ) function schedule 1 2 3 4 uint16_t rb :: Timers :: schedule ( uint32_t period_ms , std :: function < bool () > callback ) function stop 1 2 3 bool rb :: Timers :: stop ( uint16_t id ) Public Static Functions Documentation function deleteFreeRtOsTimerTask 1 static void rb :: Timers :: deleteFreeRtOsTimerTask () function get 1 static Timers & rb :: Timers :: get () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXTimers.h","title":"Class rb::Timers"},{"location":"api/classrb_1_1Timers/#class-rbtimers","text":"Class List > rb > Timers","title":"Class rb::Timers"},{"location":"api/classrb_1_1Timers/#public-static-attributes","text":"Type Name constexpr uint16_t INVALID_ID = = 0","title":"Public Static Attributes"},{"location":"api/classrb_1_1Timers/#public-functions","text":"Type Name bool cancel (uint16_t id) bool isOnTimerTask () const bool reset (uint16_t id, uint32_t period_ms) uint16_t schedule (uint32_t period_ms, std::function< bool()> callback) Schedule callback to fire after period (in millisecond). bool stop (uint16_t id)","title":"Public Functions"},{"location":"api/classrb_1_1Timers/#public-static-functions","text":"Type Name void deleteFreeRtOsTimerTask () If you don't plan to use FreeRTOS SW timers, call this to free up 2KB of heap. Timers & get ()","title":"Public Static Functions"},{"location":"api/classrb_1_1Timers/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"api/classrb_1_1Timers/#variable-invalid_id","text":"1 constexpr uint16_t rb :: Timers :: INVALID_ID ;","title":"variable INVALID_ID"},{"location":"api/classrb_1_1Timers/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1Timers/#function-cancel","text":"1 2 3 bool rb :: Timers :: cancel ( uint16_t id )","title":"function cancel"},{"location":"api/classrb_1_1Timers/#function-isontimertask","text":"1 bool rb :: Timers :: isOnTimerTask () const","title":"function isOnTimerTask"},{"location":"api/classrb_1_1Timers/#function-reset","text":"1 2 3 4 bool rb :: Timers :: reset ( uint16_t id , uint32_t period_ms )","title":"function reset"},{"location":"api/classrb_1_1Timers/#function-schedule","text":"1 2 3 4 uint16_t rb :: Timers :: schedule ( uint32_t period_ms , std :: function < bool () > callback )","title":"function schedule"},{"location":"api/classrb_1_1Timers/#function-stop","text":"1 2 3 bool rb :: Timers :: stop ( uint16_t id )","title":"function stop"},{"location":"api/classrb_1_1Timers/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"api/classrb_1_1Timers/#function-deletefreertostimertask","text":"1 static void rb :: Timers :: deleteFreeRtOsTimerTask ()","title":"function deleteFreeRtOsTimerTask"},{"location":"api/classrb_1_1Timers/#function-get","text":"1 static Timers & rb :: Timers :: get () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXTimers.h","title":"function get"},{"location":"api/classrb_1_1Ultrasound/","text":"Class rb::Ultrasound Class List > rb > Ultrasound Public Types Type Name typedef std::function< bool(uint32_t)> callback_t Public Static Attributes Type Name constexpr float defaultSpeedOfSound = = 347.13f < Default is speed at 25C, 50%, 101 kPa Public Functions Type Name float getSpeedOfSound () const bool isLastMeasurementValid () const uint32_t lastDistanceMm () const uint32_t lastDurationUs () const uint32_t measure () void measureAsync (callback_t callback=nullptr) void setSpeedOfSound (float speedOfSoundInMetersPerSecond= defaultSpeedOfSound ) Public Types Documentation typedef callback_t 1 typedef std :: function < bool ( uint32_t ) > rb :: Ultrasound :: callback_t ; Public Static Attributes Documentation variable defaultSpeedOfSound 1 constexpr float rb :: Ultrasound :: defaultSpeedOfSound ; Public Functions Documentation function getSpeedOfSound 1 inline float rb :: Ultrasound :: getSpeedOfSound () const function isLastMeasurementValid 1 inline bool rb :: Ultrasound :: isLastMeasurementValid () const function lastDistanceMm 1 inline uint32_t rb :: Ultrasound :: lastDistanceMm () const function lastDurationUs 1 inline uint32_t rb :: Ultrasound :: lastDurationUs () const function measure 1 uint32_t rb :: Ultrasound :: measure () function measureAsync 1 2 3 void rb :: Ultrasound :: measureAsync ( callback_t callback = nullptr ) function setSpeedOfSound 1 2 3 void rb :: Ultrasound :: setSpeedOfSound ( float speedOfSoundInMetersPerSecond = defaultSpeedOfSound ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXUltrasound.h","title":"Class rb::Ultrasound"},{"location":"api/classrb_1_1Ultrasound/#class-rbultrasound","text":"Class List > rb > Ultrasound","title":"Class rb::Ultrasound"},{"location":"api/classrb_1_1Ultrasound/#public-types","text":"Type Name typedef std::function< bool(uint32_t)> callback_t","title":"Public Types"},{"location":"api/classrb_1_1Ultrasound/#public-static-attributes","text":"Type Name constexpr float defaultSpeedOfSound = = 347.13f < Default is speed at 25C, 50%, 101 kPa","title":"Public Static Attributes"},{"location":"api/classrb_1_1Ultrasound/#public-functions","text":"Type Name float getSpeedOfSound () const bool isLastMeasurementValid () const uint32_t lastDistanceMm () const uint32_t lastDurationUs () const uint32_t measure () void measureAsync (callback_t callback=nullptr) void setSpeedOfSound (float speedOfSoundInMetersPerSecond= defaultSpeedOfSound )","title":"Public Functions"},{"location":"api/classrb_1_1Ultrasound/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/classrb_1_1Ultrasound/#typedef-callback_t","text":"1 typedef std :: function < bool ( uint32_t ) > rb :: Ultrasound :: callback_t ;","title":"typedef callback_t"},{"location":"api/classrb_1_1Ultrasound/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"api/classrb_1_1Ultrasound/#variable-defaultspeedofsound","text":"1 constexpr float rb :: Ultrasound :: defaultSpeedOfSound ;","title":"variable defaultSpeedOfSound"},{"location":"api/classrb_1_1Ultrasound/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/classrb_1_1Ultrasound/#function-getspeedofsound","text":"1 inline float rb :: Ultrasound :: getSpeedOfSound () const","title":"function getSpeedOfSound"},{"location":"api/classrb_1_1Ultrasound/#function-islastmeasurementvalid","text":"1 inline bool rb :: Ultrasound :: isLastMeasurementValid () const","title":"function isLastMeasurementValid"},{"location":"api/classrb_1_1Ultrasound/#function-lastdistancemm","text":"1 inline uint32_t rb :: Ultrasound :: lastDistanceMm () const","title":"function lastDistanceMm"},{"location":"api/classrb_1_1Ultrasound/#function-lastdurationus","text":"1 inline uint32_t rb :: Ultrasound :: lastDurationUs () const","title":"function lastDurationUs"},{"location":"api/classrb_1_1Ultrasound/#function-measure","text":"1 uint32_t rb :: Ultrasound :: measure ()","title":"function measure"},{"location":"api/classrb_1_1Ultrasound/#function-measureasync","text":"1 2 3 void rb :: Ultrasound :: measureAsync ( callback_t callback = nullptr )","title":"function measureAsync"},{"location":"api/classrb_1_1Ultrasound/#function-setspeedofsound","text":"1 2 3 void rb :: Ultrasound :: setSpeedOfSound ( float speedOfSoundInMetersPerSecond = defaultSpeedOfSound ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXUltrasound.h","title":"function setSpeedOfSound"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/","text":"Struct rb::SmartServoBus::servo_info Class List > servo_info Public Attributes Type Name bool auto_stop uint8_t auto_stop_counter uint16_t current float speed_coef float speed_raise float speed_target uint16_t target Public Functions Type Name bool hasValidCurrent () const servo_info () Public Attributes Documentation variable auto_stop 1 bool rb :: SmartServoBus :: servo_info :: auto_stop ; variable auto_stop_counter 1 uint8_t rb :: SmartServoBus :: servo_info :: auto_stop_counter ; variable current 1 uint16_t rb :: SmartServoBus :: servo_info :: current ; variable speed_coef 1 float rb :: SmartServoBus :: servo_info :: speed_coef ; variable speed_raise 1 float rb :: SmartServoBus :: servo_info :: speed_raise ; variable speed_target 1 float rb :: SmartServoBus :: servo_info :: speed_target ; variable target 1 uint16_t rb :: SmartServoBus :: servo_info :: target ; Public Functions Documentation function hasValidCurrent 1 inline bool servo_info :: hasValidCurrent () const function servo_info 1 inline servo_info :: servo_info () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXSmartServo.h","title":"Struct rb::SmartServoBus::servo\\_info"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#struct-rbsmartservobusservo_info","text":"Class List > servo_info","title":"Struct rb::SmartServoBus::servo_info"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#public-attributes","text":"Type Name bool auto_stop uint8_t auto_stop_counter uint16_t current float speed_coef float speed_raise float speed_target uint16_t target","title":"Public Attributes"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#public-functions","text":"Type Name bool hasValidCurrent () const servo_info ()","title":"Public Functions"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#variable-auto_stop","text":"1 bool rb :: SmartServoBus :: servo_info :: auto_stop ;","title":"variable auto_stop"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#variable-auto_stop_counter","text":"1 uint8_t rb :: SmartServoBus :: servo_info :: auto_stop_counter ;","title":"variable auto_stop_counter"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#variable-current","text":"1 uint16_t rb :: SmartServoBus :: servo_info :: current ;","title":"variable current"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#variable-speed_coef","text":"1 float rb :: SmartServoBus :: servo_info :: speed_coef ;","title":"variable speed_coef"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#variable-speed_raise","text":"1 float rb :: SmartServoBus :: servo_info :: speed_raise ;","title":"variable speed_raise"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#variable-speed_target","text":"1 float rb :: SmartServoBus :: servo_info :: speed_target ;","title":"variable speed_target"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#variable-target","text":"1 uint16_t rb :: SmartServoBus :: servo_info :: target ;","title":"variable target"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#function-hasvalidcurrent","text":"1 inline bool servo_info :: hasValidCurrent () const","title":"function hasValidCurrent"},{"location":"api/structrb_1_1SmartServoBus_1_1servo__info/#function-servo_info","text":"1 inline servo_info :: servo_info () The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXSmartServo.h","title":"function servo_info"},{"location":"api/structrb_1_1Timers_1_1timer__t/","text":"Struct rb::Timers::timer_t Class List > timer_t Public Attributes Type Name std::function< bool()> callback esp_timer_handle_t handle uint16_t id Public Functions Type Name void swap (timer_t & o) Public Attributes Documentation variable callback 1 std :: function < bool () > rb :: Timers :: timer_t :: callback ; variable handle 1 esp_timer_handle_t rb :: Timers :: timer_t :: handle ; variable id 1 uint16_t rb :: Timers :: timer_t :: id ; Public Functions Documentation function swap 1 2 3 inline void timer_t :: swap ( timer_t & o ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXTimers.h","title":"Struct rb::Timers::timer\\_t"},{"location":"api/structrb_1_1Timers_1_1timer__t/#struct-rbtimerstimer_t","text":"Class List > timer_t","title":"Struct rb::Timers::timer_t"},{"location":"api/structrb_1_1Timers_1_1timer__t/#public-attributes","text":"Type Name std::function< bool()> callback esp_timer_handle_t handle uint16_t id","title":"Public Attributes"},{"location":"api/structrb_1_1Timers_1_1timer__t/#public-functions","text":"Type Name void swap (timer_t & o)","title":"Public Functions"},{"location":"api/structrb_1_1Timers_1_1timer__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/structrb_1_1Timers_1_1timer__t/#variable-callback","text":"1 std :: function < bool () > rb :: Timers :: timer_t :: callback ;","title":"variable callback"},{"location":"api/structrb_1_1Timers_1_1timer__t/#variable-handle","text":"1 esp_timer_handle_t rb :: Timers :: timer_t :: handle ;","title":"variable handle"},{"location":"api/structrb_1_1Timers_1_1timer__t/#variable-id","text":"1 uint16_t rb :: Timers :: timer_t :: id ;","title":"variable id"},{"location":"api/structrb_1_1Timers_1_1timer__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/structrb_1_1Timers_1_1timer__t/#function-swap","text":"1 2 3 inline void timer_t :: swap ( timer_t & o ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXTimers.h","title":"function swap"},{"location":"api/dir_4fef79e7177ba769987a8da36c892c5f/","text":"Dir build File List > build Directories Type Name dir RB3204-RBCX-library The documentation for this class was generated from the following file build/","title":"Dir build"},{"location":"api/dir_4fef79e7177ba769987a8da36c892c5f/#dir-build","text":"File List > build","title":"Dir build"},{"location":"api/dir_4fef79e7177ba769987a8da36c892c5f/#directories","text":"Type Name dir RB3204-RBCX-library The documentation for this class was generated from the following file build/","title":"Directories"},{"location":"api/dir_6e2f6bf38ad600996f360c484704d30b/","text":"Dir build/RB3204-RBCX-library File List > build > RB3204-RBCX-library Directories Type Name dir src The documentation for this class was generated from the following file build/RB3204-RBCX-library/","title":"Dir build/RB3204-RBCX-library"},{"location":"api/dir_6e2f6bf38ad600996f360c484704d30b/#dir-buildrb3204-rbcx-library","text":"File List > build > RB3204-RBCX-library","title":"Dir build/RB3204-RBCX-library"},{"location":"api/dir_6e2f6bf38ad600996f360c484704d30b/#directories","text":"Type Name dir src The documentation for this class was generated from the following file build/RB3204-RBCX-library/","title":"Directories"},{"location":"api/dir_2fb57cfb6554052417264f60890e0af6/","text":"Dir build/RB3204-RBCX-library/src File List > build > RB3204-RBCX-library > src Files Type Name file RBCX.h file RBCXAngle.cpp file RBCXAngle.h file RBCXBattery.cpp file RBCXBattery.h file RBCXButtons.cpp file RBCXButtons.h file RBCXLeds.cpp file RBCXLeds.h file RBCXManager.cpp file RBCXManager.h file RBCXMotor.cpp file RBCXMotor.h file RBCXNvs.cpp file RBCXNvs.h file RBCXPiezo.cpp file RBCXPiezo.h file RBCXPinout.h file RBCXSmartServo.cpp file RBCXSmartServo.h file RBCXStupidServo.cpp file RBCXStupidServo.h file RBCXTimers.cpp file RBCXTimers.h file RBCXUltrasound.cpp file RBCXUltrasound.h file RBCXUtil.h file RBCXVersion.h The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/","title":"Dir build/RB3204-RBCX-library/src"},{"location":"api/dir_2fb57cfb6554052417264f60890e0af6/#dir-buildrb3204-rbcx-librarysrc","text":"File List > build > RB3204-RBCX-library > src","title":"Dir build/RB3204-RBCX-library/src"},{"location":"api/dir_2fb57cfb6554052417264f60890e0af6/#files","text":"Type Name file RBCX.h file RBCXAngle.cpp file RBCXAngle.h file RBCXBattery.cpp file RBCXBattery.h file RBCXButtons.cpp file RBCXButtons.h file RBCXLeds.cpp file RBCXLeds.h file RBCXManager.cpp file RBCXManager.h file RBCXMotor.cpp file RBCXMotor.h file RBCXNvs.cpp file RBCXNvs.h file RBCXPiezo.cpp file RBCXPiezo.h file RBCXPinout.h file RBCXSmartServo.cpp file RBCXSmartServo.h file RBCXStupidServo.cpp file RBCXStupidServo.h file RBCXTimers.cpp file RBCXTimers.h file RBCXUltrasound.cpp file RBCXUltrasound.h file RBCXUtil.h file RBCXVersion.h The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/","title":"Files"},{"location":"api/RBCX_8h/","text":"File RBCX.h File List > build > RB3204-RBCX-library > src > RBCX.h Go to the source code of this file. #include \"RBCXManager.h\" #include \"RBCXPinout.h\" #include \"RBCXVersion.h\" The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCX.h","title":"File RBCX.h"},{"location":"api/RBCX_8h/#file-rbcxh","text":"File List > build > RB3204-RBCX-library > src > RBCX.h Go to the source code of this file. #include \"RBCXManager.h\" #include \"RBCXPinout.h\" #include \"RBCXVersion.h\" The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCX.h","title":"File RBCX.h"},{"location":"api/RBCX_8h_source/","text":"File RBCX.h File List > build > RB3204-RBCX-library > src > RBCX.h Go to the documentation of this file. 1 2 3 4 5 #pragma once #include \"RBCXManager.h\" #include \"RBCXPinout.h\" #include \"RBCXVersion.h\"","title":"File RBCX.h"},{"location":"api/RBCX_8h_source/#file-rbcxh","text":"File List > build > RB3204-RBCX-library > src > RBCX.h Go to the documentation of this file. 1 2 3 4 5 #pragma once #include \"RBCXManager.h\" #include \"RBCXPinout.h\" #include \"RBCXVersion.h\"","title":"File RBCX.h"},{"location":"api/RBCXAngle_8cpp/","text":"File RBCXAngle.cpp File List > build > RB3204-RBCX-library > src > RBCXAngle.cpp Go to the source code of this file. #include \"RBCXAngle.h\" Namespaces Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXAngle.cpp","title":"File RBCXAngle.cpp"},{"location":"api/RBCXAngle_8cpp/#file-rbcxanglecpp","text":"File List > build > RB3204-RBCX-library > src > RBCXAngle.cpp Go to the source code of this file. #include \"RBCXAngle.h\"","title":"File RBCXAngle.cpp"},{"location":"api/RBCXAngle_8cpp/#namespaces","text":"Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXAngle.cpp","title":"Namespaces"},{"location":"api/RBCXAngle_8cpp_source/","text":"File RBCXAngle.cpp File List > build > RB3204-RBCX-library > src > RBCXAngle.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \"RBCXAngle.h\" namespace rb { const Angle Angle :: Pi = Angle :: rad ( Angle :: _T ( M_PI )); Angle operator + ( Angle a , Angle b ) { a += b ; return a ; } Angle operator - ( Angle a , Angle b ) { a -= b ; return a ; } Angle operator * ( Angle a , Angle :: _T c ) { a *= c ; return a ; } Angle operator / ( Angle a , Angle :: _T c ) { a /= c ; return a ; } Angle operator \"\" _deg ( long double d ) { return Angle :: deg ( Angle :: _T ( d )); } Angle operator \"\" _rad ( long double r ) { return Angle :: rad ( Angle :: _T ( r )); } Angle operator \"\" _deg ( unsigned long long int d ) { return Angle :: deg ( d ); } Angle operator \"\" _rad ( unsigned long long int r ) { return Angle :: rad ( r ); } }; // namespace rb","title":"File RBCXAngle.cpp"},{"location":"api/RBCXAngle_8cpp_source/#file-rbcxanglecpp","text":"File List > build > RB3204-RBCX-library > src > RBCXAngle.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \"RBCXAngle.h\" namespace rb { const Angle Angle :: Pi = Angle :: rad ( Angle :: _T ( M_PI )); Angle operator + ( Angle a , Angle b ) { a += b ; return a ; } Angle operator - ( Angle a , Angle b ) { a -= b ; return a ; } Angle operator * ( Angle a , Angle :: _T c ) { a *= c ; return a ; } Angle operator / ( Angle a , Angle :: _T c ) { a /= c ; return a ; } Angle operator \"\" _deg ( long double d ) { return Angle :: deg ( Angle :: _T ( d )); } Angle operator \"\" _rad ( long double r ) { return Angle :: rad ( Angle :: _T ( r )); } Angle operator \"\" _deg ( unsigned long long int d ) { return Angle :: deg ( d ); } Angle operator \"\" _rad ( unsigned long long int r ) { return Angle :: rad ( r ); } }; // namespace rb","title":"File RBCXAngle.cpp"},{"location":"api/RBCXAngle_8h/","text":"File RBCXAngle.h File List > build > RB3204-RBCX-library > src > RBCXAngle.h Go to the source code of this file. #include <cmath> Namespaces Type Name namespace rb Classes Type Name class Angle Macros Type Name define M_PI 3.14159265358979323846 Macro Definition Documentation define M_PI 1 #define M_PI 3.14159265358979323846 The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXAngle.h","title":"File RBCXAngle.h"},{"location":"api/RBCXAngle_8h/#file-rbcxangleh","text":"File List > build > RB3204-RBCX-library > src > RBCXAngle.h Go to the source code of this file. #include <cmath>","title":"File RBCXAngle.h"},{"location":"api/RBCXAngle_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXAngle_8h/#classes","text":"Type Name class Angle","title":"Classes"},{"location":"api/RBCXAngle_8h/#macros","text":"Type Name define M_PI 3.14159265358979323846","title":"Macros"},{"location":"api/RBCXAngle_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"api/RBCXAngle_8h/#define-m_pi","text":"1 #define M_PI 3.14159265358979323846 The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXAngle.h","title":"define M_PI"},{"location":"api/RBCXAngle_8h_source/","text":"File RBCXAngle.h File List > build > RB3204-RBCX-library > src > RBCXAngle.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #pragma once #include <cmath> #ifndef M_PI #define M_PI 3.14159265358979323846 #endif namespace rb { class Angle { public : typedef float _T ; static const Angle Pi ; Angle () : _rads ( 0 ) {} static Angle rad ( _T r ) { return Angle ( r ); } static Angle deg ( _T d ) { return Angle ( d * _T ( M_PI / 180 )); } static Angle nan () { return Angle ( nanf ( \"\" )); } bool isNaN () const { return std :: isnan ( _rads ); } Angle & operator += ( Angle a ) { _rads += a . _rads ; return * this ; } Angle & operator -= ( Angle a ) { _rads -= a . _rads ; return * this ; } Angle operator - () const { return Angle ( - _rads ); } Angle & operator *= ( _T c ) { _rads *= c ; return * this ; } Angle & operator /= ( _T c ) { _rads /= c ; return * this ; } _T deg () const { return _rads * _T ( 180.0 / M_PI ); } _T rad () const { return _rads ; } private : _T _rads ; Angle ( _T r ) : _rads ( r ) {} }; Angle operator + ( Angle a , Angle b ); Angle operator - ( Angle a , Angle b ); Angle operator * ( Angle a , Angle :: _T c ); Angle operator / ( Angle a , Angle :: _T c ); Angle operator \"\" _deg ( long double d ); Angle operator \"\" _rad ( long double r ); Angle operator \"\" _deg ( unsigned long long int d ); Angle operator \"\" _rad ( unsigned long long int r ); }; // namespace rb","title":"File RBCXAngle.h"},{"location":"api/RBCXAngle_8h_source/#file-rbcxangleh","text":"File List > build > RB3204-RBCX-library > src > RBCXAngle.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #pragma once #include <cmath> #ifndef M_PI #define M_PI 3.14159265358979323846 #endif namespace rb { class Angle { public : typedef float _T ; static const Angle Pi ; Angle () : _rads ( 0 ) {} static Angle rad ( _T r ) { return Angle ( r ); } static Angle deg ( _T d ) { return Angle ( d * _T ( M_PI / 180 )); } static Angle nan () { return Angle ( nanf ( \"\" )); } bool isNaN () const { return std :: isnan ( _rads ); } Angle & operator += ( Angle a ) { _rads += a . _rads ; return * this ; } Angle & operator -= ( Angle a ) { _rads -= a . _rads ; return * this ; } Angle operator - () const { return Angle ( - _rads ); } Angle & operator *= ( _T c ) { _rads *= c ; return * this ; } Angle & operator /= ( _T c ) { _rads /= c ; return * this ; } _T deg () const { return _rads * _T ( 180.0 / M_PI ); } _T rad () const { return _rads ; } private : _T _rads ; Angle ( _T r ) : _rads ( r ) {} }; Angle operator + ( Angle a , Angle b ); Angle operator - ( Angle a , Angle b ); Angle operator * ( Angle a , Angle :: _T c ); Angle operator / ( Angle a , Angle :: _T c ); Angle operator \"\" _deg ( long double d ); Angle operator \"\" _rad ( long double r ); Angle operator \"\" _deg ( unsigned long long int d ); Angle operator \"\" _rad ( unsigned long long int r ); }; // namespace rb","title":"File RBCXAngle.h"},{"location":"api/RBCXBattery_8cpp/","text":"File RBCXBattery.cpp File List > build > RB3204-RBCX-library > src > RBCXBattery.cpp Go to the source code of this file. #include <esp_log.h> #include \"RBCXBattery.h\" #include \"RBCXManager.h\" Namespaces Type Name namespace rb Macros Type Name define TAG \"RBCXBattery\" Macro Definition Documentation define TAG 1 #define TAG \"RBCXBattery\" The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXBattery.cpp","title":"File RBCXBattery.cpp"},{"location":"api/RBCXBattery_8cpp/#file-rbcxbatterycpp","text":"File List > build > RB3204-RBCX-library > src > RBCXBattery.cpp Go to the source code of this file. #include <esp_log.h> #include \"RBCXBattery.h\" #include \"RBCXManager.h\"","title":"File RBCXBattery.cpp"},{"location":"api/RBCXBattery_8cpp/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXBattery_8cpp/#macros","text":"Type Name define TAG \"RBCXBattery\"","title":"Macros"},{"location":"api/RBCXBattery_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"api/RBCXBattery_8cpp/#define-tag","text":"1 #define TAG \"RBCXBattery\" The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXBattery.cpp","title":"define TAG"},{"location":"api/RBCXBattery_8cpp_source/","text":"File RBCXBattery.cpp File List > build > RB3204-RBCX-library > src > RBCXBattery.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <esp_log.h> #include \"RBCXBattery.h\" #include \"RBCXManager.h\" #define TAG \"RBCXBattery\" namespace rb { Battery :: Battery () {} Battery ::~ Battery () {} void Battery :: shutdown () { ESP_LOGW ( TAG , \"Shutting down.\" ); Manager :: get (). sendToCoproc ( CoprocReq { . which_payload = CoprocReq_shutdownPower_tag , }); } uint32_t Battery :: pct () const { const auto mv = voltageMv (); if ( mv <= VOLTAGE_MIN ) { return 0 ; } else if ( mv >= VOLTAGE_MAX ) { return 100 ; } else { return ( float ( mv - VOLTAGE_MIN ) / ( VOLTAGE_MAX - VOLTAGE_MIN )) * 100.f ; } } };","title":"File RBCXBattery.cpp"},{"location":"api/RBCXBattery_8cpp_source/#file-rbcxbatterycpp","text":"File List > build > RB3204-RBCX-library > src > RBCXBattery.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <esp_log.h> #include \"RBCXBattery.h\" #include \"RBCXManager.h\" #define TAG \"RBCXBattery\" namespace rb { Battery :: Battery () {} Battery ::~ Battery () {} void Battery :: shutdown () { ESP_LOGW ( TAG , \"Shutting down.\" ); Manager :: get (). sendToCoproc ( CoprocReq { . which_payload = CoprocReq_shutdownPower_tag , }); } uint32_t Battery :: pct () const { const auto mv = voltageMv (); if ( mv <= VOLTAGE_MIN ) { return 0 ; } else if ( mv >= VOLTAGE_MAX ) { return 100 ; } else { return ( float ( mv - VOLTAGE_MIN ) / ( VOLTAGE_MAX - VOLTAGE_MIN )) * 100.f ; } } };","title":"File RBCXBattery.cpp"},{"location":"api/RBCXBattery_8h/","text":"File RBCXBattery.h File List > build > RB3204-RBCX-library > src > RBCXBattery.h Go to the source code of this file. #include \"rbcx.pb.h\" Namespaces Type Name namespace rb Classes Type Name class Battery Contains the battery state and can control the robot's power. The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXBattery.h","title":"File RBCXBattery.h"},{"location":"api/RBCXBattery_8h/#file-rbcxbatteryh","text":"File List > build > RB3204-RBCX-library > src > RBCXBattery.h Go to the source code of this file. #include \"rbcx.pb.h\"","title":"File RBCXBattery.h"},{"location":"api/RBCXBattery_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXBattery_8h/#classes","text":"Type Name class Battery Contains the battery state and can control the robot's power. The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXBattery.h","title":"Classes"},{"location":"api/RBCXBattery_8h_source/","text":"File RBCXBattery.h File List > build > RB3204-RBCX-library > src > RBCXBattery.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #pragma once #include \"rbcx.pb.h\" namespace rb { class Manager ; class Battery { friend class Manager ; public : static constexpr uint32_t VOLTAGE_MIN = 3300 * 2 ; static constexpr uint32_t VOLTAGE_MAX = 4200 * 2 ; static constexpr uint32_t BATTERY_IN_THRESHOLD = 5000 ; uint32_t pct () const ; uint32_t voltageMv () const { return m_state . vccMv ; } uint32_t bMidVoltageMv () const { return m_state . battMidMv ; } int32_t temperatureC () const { return m_state . temperatureC ; } void shutdown (); bool isPoweredByBattery () const { return voltageMv () > BATTERY_IN_THRESHOLD ; } private : Battery (); Battery ( const Battery & ) = delete ; ~ Battery (); void setState ( const CoprocStat_PowerAdcStat & msg ) { m_state = msg ; } CoprocStat_PowerAdcStat m_state ; }; };","title":"File RBCXBattery.h"},{"location":"api/RBCXBattery_8h_source/#file-rbcxbatteryh","text":"File List > build > RB3204-RBCX-library > src > RBCXBattery.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #pragma once #include \"rbcx.pb.h\" namespace rb { class Manager ; class Battery { friend class Manager ; public : static constexpr uint32_t VOLTAGE_MIN = 3300 * 2 ; static constexpr uint32_t VOLTAGE_MAX = 4200 * 2 ; static constexpr uint32_t BATTERY_IN_THRESHOLD = 5000 ; uint32_t pct () const ; uint32_t voltageMv () const { return m_state . vccMv ; } uint32_t bMidVoltageMv () const { return m_state . battMidMv ; } int32_t temperatureC () const { return m_state . temperatureC ; } void shutdown (); bool isPoweredByBattery () const { return voltageMv () > BATTERY_IN_THRESHOLD ; } private : Battery (); Battery ( const Battery & ) = delete ; ~ Battery (); void setState ( const CoprocStat_PowerAdcStat & msg ) { m_state = msg ; } CoprocStat_PowerAdcStat m_state ; }; };","title":"File RBCXBattery.h"},{"location":"api/RBCXButtons_8cpp/","text":"File RBCXButtons.cpp File List > build > RB3204-RBCX-library > src > RBCXButtons.cpp Go to the source code of this file. #include \"RBCXButtons.h\" Namespaces Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXButtons.cpp","title":"File RBCXButtons.cpp"},{"location":"api/RBCXButtons_8cpp/#file-rbcxbuttonscpp","text":"File List > build > RB3204-RBCX-library > src > RBCXButtons.cpp Go to the source code of this file. #include \"RBCXButtons.h\"","title":"File RBCXButtons.cpp"},{"location":"api/RBCXButtons_8cpp/#namespaces","text":"Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXButtons.cpp","title":"Namespaces"},{"location":"api/RBCXButtons_8cpp_source/","text":"File RBCXButtons.cpp File List > build > RB3204-RBCX-library > src > RBCXButtons.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \"RBCXButtons.h\" namespace rb { Buttons :: Buttons () : m_buttonsSet {} {} Buttons ::~ Buttons () {} void Buttons :: setState ( const CoprocStat_ButtonsStat & msg ) { const uint32_t diff = m_buttonsSet ^ ( ButtonId ) msg . buttonsPressed ; if ( diff == 0 ) return ; m_buttonsSet = ( ButtonId ) msg . buttonsPressed ; std :: lock_guard < std :: recursive_mutex > l ( m_mutex ); for ( uint32_t i = 0 ; i < Count ; ++ i ) { if (( diff & ( 1 << i )) == 0 ) continue ; for ( size_t x = 0 ; x < m_callbacks . size ();) { const auto id = ButtonId ( 1 << i ); if ( ! m_callbacks [ x ]( id , byId ( id ))) { m_callbacks . erase ( m_callbacks . begin () + x ); } else { ++ x ; } } } } void Buttons :: onChange ( callback_t callback ) { std :: lock_guard < std :: recursive_mutex > l ( m_mutex ); m_callbacks . emplace_back ( std :: move ( callback )); } };","title":"File RBCXButtons.cpp"},{"location":"api/RBCXButtons_8cpp_source/#file-rbcxbuttonscpp","text":"File List > build > RB3204-RBCX-library > src > RBCXButtons.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \"RBCXButtons.h\" namespace rb { Buttons :: Buttons () : m_buttonsSet {} {} Buttons ::~ Buttons () {} void Buttons :: setState ( const CoprocStat_ButtonsStat & msg ) { const uint32_t diff = m_buttonsSet ^ ( ButtonId ) msg . buttonsPressed ; if ( diff == 0 ) return ; m_buttonsSet = ( ButtonId ) msg . buttonsPressed ; std :: lock_guard < std :: recursive_mutex > l ( m_mutex ); for ( uint32_t i = 0 ; i < Count ; ++ i ) { if (( diff & ( 1 << i )) == 0 ) continue ; for ( size_t x = 0 ; x < m_callbacks . size ();) { const auto id = ButtonId ( 1 << i ); if ( ! m_callbacks [ x ]( id , byId ( id ))) { m_callbacks . erase ( m_callbacks . begin () + x ); } else { ++ x ; } } } } void Buttons :: onChange ( callback_t callback ) { std :: lock_guard < std :: recursive_mutex > l ( m_mutex ); m_callbacks . emplace_back ( std :: move ( callback )); } };","title":"File RBCXButtons.cpp"},{"location":"api/RBCXButtons_8h/","text":"File RBCXButtons.h File List > build > RB3204-RBCX-library > src > RBCXButtons.h Go to the source code of this file. #include <functional> #include <mutex> #include <vector> #include \"RBCXUtil.h\" #include \"rbcx.pb.h\" Namespaces Type Name namespace rb Classes Type Name class Buttons The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXButtons.h","title":"File RBCXButtons.h"},{"location":"api/RBCXButtons_8h/#file-rbcxbuttonsh","text":"File List > build > RB3204-RBCX-library > src > RBCXButtons.h Go to the source code of this file. #include <functional> #include <mutex> #include <vector> #include \"RBCXUtil.h\" #include \"rbcx.pb.h\"","title":"File RBCXButtons.h"},{"location":"api/RBCXButtons_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXButtons_8h/#classes","text":"Type Name class Buttons The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXButtons.h","title":"Classes"},{"location":"api/RBCXButtons_8h_source/","text":"File RBCXButtons.h File List > build > RB3204-RBCX-library > src > RBCXButtons.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #pragma once #include <functional> #include <mutex> #include <vector> #include \"RBCXUtil.h\" #include \"rbcx.pb.h\" // Arduino defines B1... #ifdef B1 #undef B1 #endif namespace rb { enum ButtonId : uint32_t { Off = CoprocStat_ButtonsEnum_BOFF , On = CoprocStat_ButtonsEnum_BON , B1 = CoprocStat_ButtonsEnum_B1 , B2 = CoprocStat_ButtonsEnum_B2 , B3 = CoprocStat_ButtonsEnum_B3 , B4 = CoprocStat_ButtonsEnum_B4 , Up = B1 , Down = B2 , Left = B3 , Right = B4 , }; RBCX_ENUM_IMPL_MASK_OPERATORS ( ButtonId ) class Buttons { friend class Manager ; public : typedef std :: function < bool ( ButtonId , bool ) > callback_t ; static constexpr uint32_t Count = 6 ; inline bool byId ( ButtonId id ) const { return ( m_buttonsSet & id ) != 0 ; }; inline bool up () const { return byId ( ButtonId :: Up ); } inline bool down () const { return byId ( ButtonId :: Down ); } inline bool left () const { return byId ( ButtonId :: Left ); } inline bool right () const { return byId ( ButtonId :: Right ); } inline bool on () const { return byId ( ButtonId :: On ); } inline bool off () const { return byId ( ButtonId :: Off ); } void onChange ( callback_t callback ); private : Buttons (); Buttons ( const Buttons & ) = delete ; ~ Buttons (); void setState ( const CoprocStat_ButtonsStat & msg ); std :: vector < callback_t > m_callbacks ; std :: recursive_mutex m_mutex ; ButtonId m_buttonsSet ; }; };","title":"File RBCXButtons.h"},{"location":"api/RBCXButtons_8h_source/#file-rbcxbuttonsh","text":"File List > build > RB3204-RBCX-library > src > RBCXButtons.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #pragma once #include <functional> #include <mutex> #include <vector> #include \"RBCXUtil.h\" #include \"rbcx.pb.h\" // Arduino defines B1... #ifdef B1 #undef B1 #endif namespace rb { enum ButtonId : uint32_t { Off = CoprocStat_ButtonsEnum_BOFF , On = CoprocStat_ButtonsEnum_BON , B1 = CoprocStat_ButtonsEnum_B1 , B2 = CoprocStat_ButtonsEnum_B2 , B3 = CoprocStat_ButtonsEnum_B3 , B4 = CoprocStat_ButtonsEnum_B4 , Up = B1 , Down = B2 , Left = B3 , Right = B4 , }; RBCX_ENUM_IMPL_MASK_OPERATORS ( ButtonId ) class Buttons { friend class Manager ; public : typedef std :: function < bool ( ButtonId , bool ) > callback_t ; static constexpr uint32_t Count = 6 ; inline bool byId ( ButtonId id ) const { return ( m_buttonsSet & id ) != 0 ; }; inline bool up () const { return byId ( ButtonId :: Up ); } inline bool down () const { return byId ( ButtonId :: Down ); } inline bool left () const { return byId ( ButtonId :: Left ); } inline bool right () const { return byId ( ButtonId :: Right ); } inline bool on () const { return byId ( ButtonId :: On ); } inline bool off () const { return byId ( ButtonId :: Off ); } void onChange ( callback_t callback ); private : Buttons (); Buttons ( const Buttons & ) = delete ; ~ Buttons (); void setState ( const CoprocStat_ButtonsStat & msg ); std :: vector < callback_t > m_callbacks ; std :: recursive_mutex m_mutex ; ButtonId m_buttonsSet ; }; };","title":"File RBCXButtons.h"},{"location":"api/RBCXLeds_8cpp/","text":"File RBCXLeds.cpp File List > build > RB3204-RBCX-library > src > RBCXLeds.cpp Go to the source code of this file. #include \"RBCXLeds.h\" #include \"RBCXManager.h\" Namespaces Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXLeds.cpp","title":"File RBCXLeds.cpp"},{"location":"api/RBCXLeds_8cpp/#file-rbcxledscpp","text":"File List > build > RB3204-RBCX-library > src > RBCXLeds.cpp Go to the source code of this file. #include \"RBCXLeds.h\" #include \"RBCXManager.h\"","title":"File RBCXLeds.cpp"},{"location":"api/RBCXLeds_8cpp/#namespaces","text":"Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXLeds.cpp","title":"Namespaces"},{"location":"api/RBCXLeds_8cpp_source/","text":"File RBCXLeds.cpp File List > build > RB3204-RBCX-library > src > RBCXLeds.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \"RBCXLeds.h\" #include \"RBCXManager.h\" namespace rb { Leds :: Leds () : m_ledsOn {} {} Leds ::~ Leds () {} void Leds :: red ( bool on ) { byId ( LedId :: Red , on ); } void Leds :: yellow ( bool on ) { byId ( LedId :: Yellow , on ); } void Leds :: green ( bool on ) { byId ( LedId :: Green , on ); } void Leds :: blue ( bool on ) { byId ( LedId :: Blue , on ); } void Leds :: byId ( LedId id , bool on ) { std :: lock_guard < std :: mutex > l ( m_mutex ); auto newState = m_ledsOn ; if ( on ) { newState |= id ; } else { newState &= ~ id ; } if ( newState == m_ledsOn ) return ; m_ledsOn = newState ; const CoprocReq req = { . which_payload = CoprocReq_setLeds_tag , . payload = { . setLeds = { . ledsOn = ( CoprocReq_LedsEnum ) newState , } }, }; Manager :: get (). sendToCoproc ( req ); } };","title":"File RBCXLeds.cpp"},{"location":"api/RBCXLeds_8cpp_source/#file-rbcxledscpp","text":"File List > build > RB3204-RBCX-library > src > RBCXLeds.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \"RBCXLeds.h\" #include \"RBCXManager.h\" namespace rb { Leds :: Leds () : m_ledsOn {} {} Leds ::~ Leds () {} void Leds :: red ( bool on ) { byId ( LedId :: Red , on ); } void Leds :: yellow ( bool on ) { byId ( LedId :: Yellow , on ); } void Leds :: green ( bool on ) { byId ( LedId :: Green , on ); } void Leds :: blue ( bool on ) { byId ( LedId :: Blue , on ); } void Leds :: byId ( LedId id , bool on ) { std :: lock_guard < std :: mutex > l ( m_mutex ); auto newState = m_ledsOn ; if ( on ) { newState |= id ; } else { newState &= ~ id ; } if ( newState == m_ledsOn ) return ; m_ledsOn = newState ; const CoprocReq req = { . which_payload = CoprocReq_setLeds_tag , . payload = { . setLeds = { . ledsOn = ( CoprocReq_LedsEnum ) newState , } }, }; Manager :: get (). sendToCoproc ( req ); } };","title":"File RBCXLeds.cpp"},{"location":"api/RBCXLeds_8h/","text":"File RBCXLeds.h File List > build > RB3204-RBCX-library > src > RBCXLeds.h Go to the source code of this file. #include <mutex> #include \"RBCXUtil.h\" #include \"rbcx.pb.h\" Namespaces Type Name namespace rb Classes Type Name class Leds The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXLeds.h","title":"File RBCXLeds.h"},{"location":"api/RBCXLeds_8h/#file-rbcxledsh","text":"File List > build > RB3204-RBCX-library > src > RBCXLeds.h Go to the source code of this file. #include <mutex> #include \"RBCXUtil.h\" #include \"rbcx.pb.h\"","title":"File RBCXLeds.h"},{"location":"api/RBCXLeds_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXLeds_8h/#classes","text":"Type Name class Leds The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXLeds.h","title":"Classes"},{"location":"api/RBCXLeds_8h_source/","text":"File RBCXLeds.h File List > build > RB3204-RBCX-library > src > RBCXLeds.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #pragma once #include <mutex> #include \"RBCXUtil.h\" #include \"rbcx.pb.h\" namespace rb { enum LedId { L1 = CoprocReq_LedsEnum_L1 , L2 = CoprocReq_LedsEnum_L2 , L3 = CoprocReq_LedsEnum_L3 , L4 = CoprocReq_LedsEnum_L4 , Green = L1 , Yellow = L2 , Red = L3 , Blue = L4 , All = L1 | L2 | L3 | L4 , }; RBCX_ENUM_IMPL_MASK_OPERATORS ( LedId ) class Leds { friend class Manager ; public : void red ( bool on = true ); void yellow ( bool on = true ); void green ( bool on = true ); void blue ( bool on = true ); void byId ( LedId id , bool on = true ); private : Leds (); Leds ( const Leds & ) = delete ; ~ Leds (); LedId m_ledsOn ; std :: mutex m_mutex ; }; };","title":"File RBCXLeds.h"},{"location":"api/RBCXLeds_8h_source/#file-rbcxledsh","text":"File List > build > RB3204-RBCX-library > src > RBCXLeds.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #pragma once #include <mutex> #include \"RBCXUtil.h\" #include \"rbcx.pb.h\" namespace rb { enum LedId { L1 = CoprocReq_LedsEnum_L1 , L2 = CoprocReq_LedsEnum_L2 , L3 = CoprocReq_LedsEnum_L3 , L4 = CoprocReq_LedsEnum_L4 , Green = L1 , Yellow = L2 , Red = L3 , Blue = L4 , All = L1 | L2 | L3 | L4 , }; RBCX_ENUM_IMPL_MASK_OPERATORS ( LedId ) class Leds { friend class Manager ; public : void red ( bool on = true ); void yellow ( bool on = true ); void green ( bool on = true ); void blue ( bool on = true ); void byId ( LedId id , bool on = true ); private : Leds (); Leds ( const Leds & ) = delete ; ~ Leds (); LedId m_ledsOn ; std :: mutex m_mutex ; }; };","title":"File RBCXLeds.h"},{"location":"api/RBCXManager_8cpp/","text":"File RBCXManager.cpp File List > build > RB3204-RBCX-library > src > RBCXManager.cpp Go to the source code of this file. #include <driver/i2c.h> #include <driver/uart.h> #include <esp_log.h> #include <freertos/FreeRTOS.h> #include <freertos/task.h> #include \"RBCXBattery.h\" #include \"RBCXManager.h\" #include \"rbcx.pb.h\" Namespaces Type Name namespace rb Macros Type Name define MAX_COPROC_IDLE_MS 75 define MOTORS_FAILSAFE_PERIOD_MS 300 define TAG \"RBCXManager\" Macro Definition Documentation define MAX_COPROC_IDLE_MS 1 #define MAX_COPROC_IDLE_MS 75 define MOTORS_FAILSAFE_PERIOD_MS 1 #define MOTORS_FAILSAFE_PERIOD_MS 300 define TAG 1 #define TAG \"RBCXManager\" The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXManager.cpp","title":"File RBCXManager.cpp"},{"location":"api/RBCXManager_8cpp/#file-rbcxmanagercpp","text":"File List > build > RB3204-RBCX-library > src > RBCXManager.cpp Go to the source code of this file. #include <driver/i2c.h> #include <driver/uart.h> #include <esp_log.h> #include <freertos/FreeRTOS.h> #include <freertos/task.h> #include \"RBCXBattery.h\" #include \"RBCXManager.h\" #include \"rbcx.pb.h\"","title":"File RBCXManager.cpp"},{"location":"api/RBCXManager_8cpp/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXManager_8cpp/#macros","text":"Type Name define MAX_COPROC_IDLE_MS 75 define MOTORS_FAILSAFE_PERIOD_MS 300 define TAG \"RBCXManager\"","title":"Macros"},{"location":"api/RBCXManager_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"api/RBCXManager_8cpp/#define-max_coproc_idle_ms","text":"1 #define MAX_COPROC_IDLE_MS 75","title":"define MAX_COPROC_IDLE_MS"},{"location":"api/RBCXManager_8cpp/#define-motors_failsafe_period_ms","text":"1 #define MOTORS_FAILSAFE_PERIOD_MS 300","title":"define MOTORS_FAILSAFE_PERIOD_MS"},{"location":"api/RBCXManager_8cpp/#define-tag","text":"1 #define TAG \"RBCXManager\" The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXManager.cpp","title":"define TAG"},{"location":"api/RBCXManager_8cpp_source/","text":"File RBCXManager.cpp File List > build > RB3204-RBCX-library > src > RBCXManager.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 #include <driver/i2c.h> #include <driver/uart.h> #include <esp_log.h> #include <freertos/FreeRTOS.h> #include <freertos/task.h> #include \"RBCXBattery.h\" #include \"RBCXManager.h\" #include \"rbcx.pb.h\" #define TAG \"RBCXManager\" #define MOTORS_FAILSAFE_PERIOD_MS 300 #define MAX_COPROC_IDLE_MS 75 namespace rb { Manager :: Manager () : m_keepaliveTask ( nullptr ) , m_coprocFwVersion ( CoprocStat_VersionStat_init_zero ) {} Manager ::~ Manager () {} void Manager :: install ( ManagerInstallFlags flags , BaseType_t managerLoopStackSize ) { if ( m_keepaliveTask != nullptr ) { ESP_LOGE ( TAG , \"The manager has already been installed, please make sure to \" \"only call install() once!\" ); abort (); } for ( int i = 0 ; i < UltrasoundsCount ; ++ i ) { m_ultrasounds [ i ]. init ( i ); } for ( int i = 0 ; i < StupidServosCount ; ++ i ) { m_stupidServos [ i ]. setId ( i ); } for ( MotorId id = MotorId :: M1 ; id < MotorId :: MAX ; ++ id ) { m_motors [ size_t ( id )]. setId ( id ); } m_motors_last_set = 0 ; if ( ! ( flags & MAN_DISABLE_MOTOR_FAILSAFE )) { schedule ( MOTORS_FAILSAFE_PERIOD_MS , std :: bind ( & Manager :: motorsFailSafe , this )); } const uart_config_t uart_config = { . baud_rate = 921600 , . data_bits = UART_DATA_8_BITS , . parity = UART_PARITY_DISABLE , . stop_bits = UART_STOP_BITS_1 , . flow_ctrl = UART_HW_FLOWCTRL_DISABLE , }; ESP_ERROR_CHECK ( uart_param_config ( UART_NUM_2 , & uart_config )); ESP_ERROR_CHECK ( uart_set_pin ( UART_NUM_2 , GPIO_NUM_2 , GPIO_NUM_0 , UART_PIN_NO_CHANGE , UART_PIN_NO_CHANGE )); ESP_ERROR_CHECK ( uart_driver_install ( UART_NUM_2 , 1024 , 0 , 0 , NULL , 0 )); m_coprocSemaphore = xSemaphoreCreateBinary (); // The esp_timer (-> rb::Timers) task runs pinned on core 0, which gets stalled // for ~700 ms(?!) when connecting to a WiFi network, so it can't be used // for this watchdog. xTaskCreate ( & Manager :: keepaliveRoutine , \"rbmanager_keepalive\" , 1536 , this , 10 , & m_keepaliveTask ); monitorTask ( m_keepaliveTask ); TaskHandle_t task ; xTaskCreate ( & Manager :: consumerRoutineTrampoline , \"rbmanager_loop\" , managerLoopStackSize , this , 5 , & task ); monitorTask ( task ); sendToCoproc ( CoprocReq { . which_payload = CoprocReq_versionReq_tag }); sendToCoproc ( CoprocReq { . which_payload = CoprocReq_getButtons_tag }); if ( xSemaphoreTake ( m_coprocSemaphore , pdMS_TO_TICKS ( 300 )) != pdTRUE ) { ESP_LOGE ( TAG , \"failed to acquire FW version from STM32, message not received in \" \"300ms. \\n \" ); } #ifdef RB_DEBUG_MONITOR_TASKS schedule ( 10000 , [ & ]() { return printTasksDebugInfo (); }); #endif } /*rb::SmartServoBus& Manager::initSmartServoBus(uint8_t servo_count) { m_servos.install(servo_count); return m_servos; }*/ void Manager :: consumerRoutineTrampoline ( void * cookie ) { (( Manager * ) cookie ) -> consumerRoutine (); } void Manager :: consumerRoutine () { CoprocLinkParser < CoprocStat , & CoprocStat_msg > parser ( m_codec ); while ( true ) { uint8_t byte ; if ( uart_read_bytes ( UART_NUM_2 , & byte , 1 , portMAX_DELAY ) != 1 ) { ESP_LOGE ( TAG , \"Invalid uart read \\n \" ); continue ; } if ( ! parser . add ( byte )) continue ; const auto & msg = parser . lastMessage (); switch ( msg . which_payload ) { case CoprocStat_buttonsStat_tag : m_buttons . setState ( msg . payload . buttonsStat ); break ; case CoprocStat_ultrasoundStat_tag : { const auto & p = msg . payload . ultrasoundStat ; if ( p . utsIndex >= 0 && p . utsIndex < UltrasoundsCount ) m_ultrasounds [ p . utsIndex ]. onMeasuringDone ( p ); break ; } case CoprocStat_powerAdcStat_tag : m_battery . setState ( msg . payload . powerAdcStat ); break ; case CoprocStat_versionStat_tag : m_coprocFwVersion = msg . payload . versionStat ; xSemaphoreGive ( m_coprocSemaphore ); break ; case CoprocStat_motorStat_tag : { const auto & p = msg . payload . motorStat ; if ( p . motorIndex < ( uint32_t ) MotorId :: MAX ) { m_motors [ p . motorIndex ]. onMotorStat ( p ); } break ; } case CoprocStat_ledsStat_tag : case CoprocStat_stupidServoStat_tag : // Ignore break ; default : printf ( \"Received message of unknown type from stm32: %d \\n \" , msg . which_payload ); break ; } } } void Manager :: keepaliveRoutine ( void * cookie ) { auto & man = * (( Manager * ) cookie ); while ( true ) { if ( xTaskNotifyWait ( 0 , 0 , NULL , pdMS_TO_TICKS ( MAX_COPROC_IDLE_MS )) == pdFALSE ) { man . sendToCoproc ( CoprocReq { . which_payload = CoprocReq_keepalive_tag , }); } } } void Manager :: sendToCoproc ( const CoprocReq & msg ) { m_codecTxMutex . lock (); const auto len = m_codec . encodeWithHeader ( & CoprocReq_msg , & msg , m_txBuf , sizeof ( m_txBuf )); if ( len > 0 ) { uart_write_bytes ( UART_NUM_2 , ( const char * ) m_txBuf , len ); } m_codecTxMutex . unlock (); xTaskNotify ( m_keepaliveTask , 0 , eNoAction ); } void Manager :: coprocFwVersionAssert ( uint32_t minVersion , const char * name ) { // Ignore zero version number and pass. Might be the cmd was not received yet, // but better than to crash in that case. if ( m_coprocFwVersion . number == 0 ) return ; if ( minVersion > m_coprocFwVersion . number ) { printf ( \" \\n\\n ERROR: Please update your STM32 FW, '%s' requires version \" \"0x%06x and you have 0x%06x! \\n\\n \" , name , minVersion , m_coprocFwVersion . number ); abort (); } } void Manager :: resetMotorsFailSafe () { m_motors_last_set = xTaskGetTickCount (); } bool Manager :: motorsFailSafe () { if ( m_motors_last_set != 0 ) { const auto now = xTaskGetTickCount (); if ( now - m_motors_last_set > pdMS_TO_TICKS ( MOTORS_FAILSAFE_PERIOD_MS )) { ESP_LOGE ( TAG , \"Motor failsafe triggered, stopping all motors!\" ); for ( auto & m : m_motors ) { m . power ( 0 ); } m_motors_last_set = 0 ; } } return true ; } MotorChangeBuilder Manager :: setMotors () { return MotorChangeBuilder (); } void Manager :: monitorTask ( TaskHandle_t task ) { #ifdef RB_DEBUG_MONITOR_TASKS m_tasks_mutex . lock (); m_tasks . push_back ( task ); m_tasks_mutex . unlock (); #endif } #ifdef RB_DEBUG_MONITOR_TASKS bool Manager :: printTasksDebugInfo () { std :: lock_guard < std :: mutex > lock ( m_tasks_mutex ); printf ( \"%16s %5s %5s \\n \" , \"Name\" , \"prio\" , \"stack\" ); printf ( \"========================================== \\n \" ); for ( auto task : m_tasks ) { auto stackMark = uxTaskGetStackHighWaterMark ( task ); auto prio = uxTaskPriorityGet ( task ); printf ( \"%16s %5d %5d \\n \" , pcTaskGetTaskName ( task ), ( int ) prio , ( int ) stackMark ); } return true ; } #endif MotorChangeBuilder :: MotorChangeBuilder () {} MotorChangeBuilder :: MotorChangeBuilder ( MotorChangeBuilder && o ) : m_calls ( std :: move ( o . m_calls )) {} MotorChangeBuilder ::~ MotorChangeBuilder () {} MotorChangeBuilder & MotorChangeBuilder :: power ( MotorId id , int16_t value ) { m_calls . emplace_back ( std :: move ([ = ]() { Manager :: get (). motor ( id ). power ( value ); })); return * this ; } MotorChangeBuilder & MotorChangeBuilder :: speed ( MotorId id , int16_t ticksPerSecond ) { m_calls . emplace_back ( std :: move ([ = ]() { Manager :: get (). motor ( id ). speed ( ticksPerSecond ); })); return * this ; } MotorChangeBuilder & MotorChangeBuilder :: pwmMaxPercent ( MotorId id , int8_t percent ) { m_calls . emplace_back ( std :: move ([ = ]() { Manager :: get (). motor ( id ). pwmMaxPercent ( percent ); })); return * this ; } MotorChangeBuilder & MotorChangeBuilder :: brake ( MotorId id , uint16_t brakingPower ) { m_calls . emplace_back ( std :: move ([ = ]() { Manager :: get (). motor ( id ). brake ( brakingPower ); })); return * this ; } MotorChangeBuilder & MotorChangeBuilder :: drive ( MotorId id , int32_t positionRelative , int16_t speedTicksPerSecond , Motor :: callback_t callback ) { m_calls . emplace_back ( std :: move ([ = ]() { Manager :: get (). motor ( id ). drive ( positionRelative , speedTicksPerSecond , std :: move ( callback )); })); return * this ; } MotorChangeBuilder & MotorChangeBuilder :: driveToValue ( MotorId id , int32_t positionAbsolute , int16_t speedTicksPerSecond , Motor :: callback_t callback ) { m_calls . emplace_back ( std :: move ([ = ]() { Manager :: get (). motor ( id ). driveToValue ( positionAbsolute , speedTicksPerSecond , std :: move ( callback )); })); return * this ; } void MotorChangeBuilder :: set () { for ( const auto & c : m_calls ) { c (); } m_calls . clear (); } };","title":"File RBCXManager.cpp"},{"location":"api/RBCXManager_8cpp_source/#file-rbcxmanagercpp","text":"File List > build > RB3204-RBCX-library > src > RBCXManager.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 #include <driver/i2c.h> #include <driver/uart.h> #include <esp_log.h> #include <freertos/FreeRTOS.h> #include <freertos/task.h> #include \"RBCXBattery.h\" #include \"RBCXManager.h\" #include \"rbcx.pb.h\" #define TAG \"RBCXManager\" #define MOTORS_FAILSAFE_PERIOD_MS 300 #define MAX_COPROC_IDLE_MS 75 namespace rb { Manager :: Manager () : m_keepaliveTask ( nullptr ) , m_coprocFwVersion ( CoprocStat_VersionStat_init_zero ) {} Manager ::~ Manager () {} void Manager :: install ( ManagerInstallFlags flags , BaseType_t managerLoopStackSize ) { if ( m_keepaliveTask != nullptr ) { ESP_LOGE ( TAG , \"The manager has already been installed, please make sure to \" \"only call install() once!\" ); abort (); } for ( int i = 0 ; i < UltrasoundsCount ; ++ i ) { m_ultrasounds [ i ]. init ( i ); } for ( int i = 0 ; i < StupidServosCount ; ++ i ) { m_stupidServos [ i ]. setId ( i ); } for ( MotorId id = MotorId :: M1 ; id < MotorId :: MAX ; ++ id ) { m_motors [ size_t ( id )]. setId ( id ); } m_motors_last_set = 0 ; if ( ! ( flags & MAN_DISABLE_MOTOR_FAILSAFE )) { schedule ( MOTORS_FAILSAFE_PERIOD_MS , std :: bind ( & Manager :: motorsFailSafe , this )); } const uart_config_t uart_config = { . baud_rate = 921600 , . data_bits = UART_DATA_8_BITS , . parity = UART_PARITY_DISABLE , . stop_bits = UART_STOP_BITS_1 , . flow_ctrl = UART_HW_FLOWCTRL_DISABLE , }; ESP_ERROR_CHECK ( uart_param_config ( UART_NUM_2 , & uart_config )); ESP_ERROR_CHECK ( uart_set_pin ( UART_NUM_2 , GPIO_NUM_2 , GPIO_NUM_0 , UART_PIN_NO_CHANGE , UART_PIN_NO_CHANGE )); ESP_ERROR_CHECK ( uart_driver_install ( UART_NUM_2 , 1024 , 0 , 0 , NULL , 0 )); m_coprocSemaphore = xSemaphoreCreateBinary (); // The esp_timer (-> rb::Timers) task runs pinned on core 0, which gets stalled // for ~700 ms(?!) when connecting to a WiFi network, so it can't be used // for this watchdog. xTaskCreate ( & Manager :: keepaliveRoutine , \"rbmanager_keepalive\" , 1536 , this , 10 , & m_keepaliveTask ); monitorTask ( m_keepaliveTask ); TaskHandle_t task ; xTaskCreate ( & Manager :: consumerRoutineTrampoline , \"rbmanager_loop\" , managerLoopStackSize , this , 5 , & task ); monitorTask ( task ); sendToCoproc ( CoprocReq { . which_payload = CoprocReq_versionReq_tag }); sendToCoproc ( CoprocReq { . which_payload = CoprocReq_getButtons_tag }); if ( xSemaphoreTake ( m_coprocSemaphore , pdMS_TO_TICKS ( 300 )) != pdTRUE ) { ESP_LOGE ( TAG , \"failed to acquire FW version from STM32, message not received in \" \"300ms. \\n \" ); } #ifdef RB_DEBUG_MONITOR_TASKS schedule ( 10000 , [ & ]() { return printTasksDebugInfo (); }); #endif } /*rb::SmartServoBus& Manager::initSmartServoBus(uint8_t servo_count) { m_servos.install(servo_count); return m_servos; }*/ void Manager :: consumerRoutineTrampoline ( void * cookie ) { (( Manager * ) cookie ) -> consumerRoutine (); } void Manager :: consumerRoutine () { CoprocLinkParser < CoprocStat , & CoprocStat_msg > parser ( m_codec ); while ( true ) { uint8_t byte ; if ( uart_read_bytes ( UART_NUM_2 , & byte , 1 , portMAX_DELAY ) != 1 ) { ESP_LOGE ( TAG , \"Invalid uart read \\n \" ); continue ; } if ( ! parser . add ( byte )) continue ; const auto & msg = parser . lastMessage (); switch ( msg . which_payload ) { case CoprocStat_buttonsStat_tag : m_buttons . setState ( msg . payload . buttonsStat ); break ; case CoprocStat_ultrasoundStat_tag : { const auto & p = msg . payload . ultrasoundStat ; if ( p . utsIndex >= 0 && p . utsIndex < UltrasoundsCount ) m_ultrasounds [ p . utsIndex ]. onMeasuringDone ( p ); break ; } case CoprocStat_powerAdcStat_tag : m_battery . setState ( msg . payload . powerAdcStat ); break ; case CoprocStat_versionStat_tag : m_coprocFwVersion = msg . payload . versionStat ; xSemaphoreGive ( m_coprocSemaphore ); break ; case CoprocStat_motorStat_tag : { const auto & p = msg . payload . motorStat ; if ( p . motorIndex < ( uint32_t ) MotorId :: MAX ) { m_motors [ p . motorIndex ]. onMotorStat ( p ); } break ; } case CoprocStat_ledsStat_tag : case CoprocStat_stupidServoStat_tag : // Ignore break ; default : printf ( \"Received message of unknown type from stm32: %d \\n \" , msg . which_payload ); break ; } } } void Manager :: keepaliveRoutine ( void * cookie ) { auto & man = * (( Manager * ) cookie ); while ( true ) { if ( xTaskNotifyWait ( 0 , 0 , NULL , pdMS_TO_TICKS ( MAX_COPROC_IDLE_MS )) == pdFALSE ) { man . sendToCoproc ( CoprocReq { . which_payload = CoprocReq_keepalive_tag , }); } } } void Manager :: sendToCoproc ( const CoprocReq & msg ) { m_codecTxMutex . lock (); const auto len = m_codec . encodeWithHeader ( & CoprocReq_msg , & msg , m_txBuf , sizeof ( m_txBuf )); if ( len > 0 ) { uart_write_bytes ( UART_NUM_2 , ( const char * ) m_txBuf , len ); } m_codecTxMutex . unlock (); xTaskNotify ( m_keepaliveTask , 0 , eNoAction ); } void Manager :: coprocFwVersionAssert ( uint32_t minVersion , const char * name ) { // Ignore zero version number and pass. Might be the cmd was not received yet, // but better than to crash in that case. if ( m_coprocFwVersion . number == 0 ) return ; if ( minVersion > m_coprocFwVersion . number ) { printf ( \" \\n\\n ERROR: Please update your STM32 FW, '%s' requires version \" \"0x%06x and you have 0x%06x! \\n\\n \" , name , minVersion , m_coprocFwVersion . number ); abort (); } } void Manager :: resetMotorsFailSafe () { m_motors_last_set = xTaskGetTickCount (); } bool Manager :: motorsFailSafe () { if ( m_motors_last_set != 0 ) { const auto now = xTaskGetTickCount (); if ( now - m_motors_last_set > pdMS_TO_TICKS ( MOTORS_FAILSAFE_PERIOD_MS )) { ESP_LOGE ( TAG , \"Motor failsafe triggered, stopping all motors!\" ); for ( auto & m : m_motors ) { m . power ( 0 ); } m_motors_last_set = 0 ; } } return true ; } MotorChangeBuilder Manager :: setMotors () { return MotorChangeBuilder (); } void Manager :: monitorTask ( TaskHandle_t task ) { #ifdef RB_DEBUG_MONITOR_TASKS m_tasks_mutex . lock (); m_tasks . push_back ( task ); m_tasks_mutex . unlock (); #endif } #ifdef RB_DEBUG_MONITOR_TASKS bool Manager :: printTasksDebugInfo () { std :: lock_guard < std :: mutex > lock ( m_tasks_mutex ); printf ( \"%16s %5s %5s \\n \" , \"Name\" , \"prio\" , \"stack\" ); printf ( \"========================================== \\n \" ); for ( auto task : m_tasks ) { auto stackMark = uxTaskGetStackHighWaterMark ( task ); auto prio = uxTaskPriorityGet ( task ); printf ( \"%16s %5d %5d \\n \" , pcTaskGetTaskName ( task ), ( int ) prio , ( int ) stackMark ); } return true ; } #endif MotorChangeBuilder :: MotorChangeBuilder () {} MotorChangeBuilder :: MotorChangeBuilder ( MotorChangeBuilder && o ) : m_calls ( std :: move ( o . m_calls )) {} MotorChangeBuilder ::~ MotorChangeBuilder () {} MotorChangeBuilder & MotorChangeBuilder :: power ( MotorId id , int16_t value ) { m_calls . emplace_back ( std :: move ([ = ]() { Manager :: get (). motor ( id ). power ( value ); })); return * this ; } MotorChangeBuilder & MotorChangeBuilder :: speed ( MotorId id , int16_t ticksPerSecond ) { m_calls . emplace_back ( std :: move ([ = ]() { Manager :: get (). motor ( id ). speed ( ticksPerSecond ); })); return * this ; } MotorChangeBuilder & MotorChangeBuilder :: pwmMaxPercent ( MotorId id , int8_t percent ) { m_calls . emplace_back ( std :: move ([ = ]() { Manager :: get (). motor ( id ). pwmMaxPercent ( percent ); })); return * this ; } MotorChangeBuilder & MotorChangeBuilder :: brake ( MotorId id , uint16_t brakingPower ) { m_calls . emplace_back ( std :: move ([ = ]() { Manager :: get (). motor ( id ). brake ( brakingPower ); })); return * this ; } MotorChangeBuilder & MotorChangeBuilder :: drive ( MotorId id , int32_t positionRelative , int16_t speedTicksPerSecond , Motor :: callback_t callback ) { m_calls . emplace_back ( std :: move ([ = ]() { Manager :: get (). motor ( id ). drive ( positionRelative , speedTicksPerSecond , std :: move ( callback )); })); return * this ; } MotorChangeBuilder & MotorChangeBuilder :: driveToValue ( MotorId id , int32_t positionAbsolute , int16_t speedTicksPerSecond , Motor :: callback_t callback ) { m_calls . emplace_back ( std :: move ([ = ]() { Manager :: get (). motor ( id ). driveToValue ( positionAbsolute , speedTicksPerSecond , std :: move ( callback )); })); return * this ; } void MotorChangeBuilder :: set () { for ( const auto & c : m_calls ) { c (); } m_calls . clear (); } };","title":"File RBCXManager.cpp"},{"location":"api/RBCXManager_8h/","text":"File RBCXManager.h File List > build > RB3204-RBCX-library > src > RBCXManager.h Go to the source code of this file. #include <freertos/FreeRTOS.h> #include <freertos/queue.h> #include <functional> #include <list> #include <memory> #include <mutex> #include <vector> #include \"RBCXBattery.h\" #include \"RBCXButtons.h\" #include \"RBCXLeds.h\" #include \"RBCXMotor.h\" #include \"RBCXPiezo.h\" #include \"RBCXSmartServo.h\" #include \"RBCXStupidServo.h\" #include \"RBCXTimers.h\" #include \"RBCXUltrasound.h\" #include \"coproc_link_parser.h\" #include \"rbcx.pb.h\" Namespaces Type Name namespace rb Classes Type Name class Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. class MotorChangeBuilder Helper class for building the motor change event. The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXManager.h","title":"File RBCXManager.h"},{"location":"api/RBCXManager_8h/#file-rbcxmanagerh","text":"File List > build > RB3204-RBCX-library > src > RBCXManager.h Go to the source code of this file. #include <freertos/FreeRTOS.h> #include <freertos/queue.h> #include <functional> #include <list> #include <memory> #include <mutex> #include <vector> #include \"RBCXBattery.h\" #include \"RBCXButtons.h\" #include \"RBCXLeds.h\" #include \"RBCXMotor.h\" #include \"RBCXPiezo.h\" #include \"RBCXSmartServo.h\" #include \"RBCXStupidServo.h\" #include \"RBCXTimers.h\" #include \"RBCXUltrasound.h\" #include \"coproc_link_parser.h\" #include \"rbcx.pb.h\"","title":"File RBCXManager.h"},{"location":"api/RBCXManager_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXManager_8h/#classes","text":"Type Name class Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. class MotorChangeBuilder Helper class for building the motor change event. The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXManager.h","title":"Classes"},{"location":"api/RBCXManager_8h_source/","text":"File RBCXManager.h File List > build > RB3204-RBCX-library > src > RBCXManager.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 #pragma once #include <freertos/FreeRTOS.h> #include <freertos/queue.h> #include <functional> #include <list> #include <memory> #include <mutex> #include <vector> #include \"RBCXBattery.h\" #include \"RBCXButtons.h\" #include \"RBCXLeds.h\" #include \"RBCXMotor.h\" #include \"RBCXPiezo.h\" #include \"RBCXSmartServo.h\" #include \"RBCXStupidServo.h\" #include \"RBCXTimers.h\" #include \"RBCXUltrasound.h\" #include \"coproc_link_parser.h\" #include \"rbcx.pb.h\" namespace rb { class MotorChangeBuilder ; enum ManagerInstallFlags { MAN_NONE = 0 , MAN_DISABLE_MOTOR_FAILSAFE = ( 1 << 0 ), }; inline ManagerInstallFlags operator | ( ManagerInstallFlags a , ManagerInstallFlags b ) { return static_cast < ManagerInstallFlags > ( static_cast < int > ( a ) | static_cast < int > ( b )); } // Periodically print info about all RBCX tasks to the console //#define RB_DEBUG_MONITOR_TASKS 1 class Manager { friend class MotorChangeBuilder ; friend class Encoder ; friend class PcntInterruptHandler ; friend class Motor ; public : Manager ( Manager const & ) = delete ; void operator = ( Manager const & ) = delete ; static Manager & get () { static Manager instance ; return instance ; } void install ( ManagerInstallFlags flags = MAN_NONE , BaseType_t managerLoopStackSize = 3072 ); //SmartServoBus& initSmartServoBus(uint8_t servo_count); //SmartServoBus& servoBus() { return m_servos; }; Ultrasound & ultrasound ( uint8_t index ) { return m_ultrasounds [ index ]; } StupidServo & stupidServo ( uint8_t index ) { return m_stupidServos [ index ]; } Piezo & piezo () { return m_piezo ; } Battery & battery () { return m_battery ; } Leds & leds () { return m_leds ; } Buttons & buttons () { return m_buttons ; } Motor & motor ( MotorId id ) { return m_motors [ static_cast < int > ( id )]; }; MotorChangeBuilder setMotors (); void schedule ( uint32_t period_ms , std :: function < bool () > callback ) { timers (). schedule ( period_ms , callback ); } inline Timers & timers () { return rb :: Timers :: get (); } // internal api to monitor RBCX tasks void monitorTask ( TaskHandle_t task ); void sendToCoproc ( const CoprocReq & msg ); const CoprocStat_VersionStat & coprocFwVersion () const { return m_coprocFwVersion ; } void coprocFwVersionAssert ( uint32_t minVersion , const char * name ); private : Manager (); ~ Manager (); static void consumerRoutineTrampoline ( void * cookie ); void consumerRoutine (); static void keepaliveRoutine ( void * cookie ); void resetMotorsFailSafe (); bool motorsFailSafe (); #ifdef RB_DEBUG_MONITOR_TASKS bool printTasksDebugInfo (); std :: vector < TaskHandle_t > m_tasks ; std :: mutex m_tasks_mutex ; #endif TaskHandle_t m_keepaliveTask ; CoprocCodec m_codec ; uint8_t m_txBuf [ CoprocCodec :: MaxFrameSize ]; std :: mutex m_codecTxMutex ; uint16_t m_coprocWatchdogTimer ; CoprocStat_VersionStat m_coprocFwVersion ; SemaphoreHandle_t m_coprocSemaphore ; TickType_t m_motors_last_set ; Motor m_motors [ size_t ( MotorId :: MAX )]; rb :: Piezo m_piezo ; rb :: Leds m_leds ; rb :: Buttons m_buttons ; rb :: Battery m_battery ; //rb::SmartServoBus m_servos; rb :: Ultrasound m_ultrasounds [ UltrasoundsCount ]; rb :: StupidServo m_stupidServos [ StupidServosCount ]; }; class MotorChangeBuilder { public : MotorChangeBuilder (); MotorChangeBuilder ( const MotorChangeBuilder & o ) = delete ; MotorChangeBuilder ( MotorChangeBuilder && o ); ~ MotorChangeBuilder (); MotorChangeBuilder & power ( MotorId id , int16_t value ); MotorChangeBuilder & speed ( MotorId id , int16_t ticksPerSecond ); MotorChangeBuilder & brake ( MotorId id , uint16_t brakingPower ); MotorChangeBuilder & pwmMaxPercent ( MotorId id , int8_t percent ); MotorChangeBuilder & drive ( MotorId id , int32_t positionRelative , int16_t speedTicksPerSecond , Motor :: callback_t callback = nullptr ); MotorChangeBuilder & driveToValue ( MotorId id , int32_t positionAbsolute , int16_t speedTicksPerSecond , Motor :: callback_t callback = nullptr ); void set (); private : std :: vector < std :: function < void () >> m_calls ; }; } // namespace rb","title":"File RBCXManager.h"},{"location":"api/RBCXManager_8h_source/#file-rbcxmanagerh","text":"File List > build > RB3204-RBCX-library > src > RBCXManager.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 #pragma once #include <freertos/FreeRTOS.h> #include <freertos/queue.h> #include <functional> #include <list> #include <memory> #include <mutex> #include <vector> #include \"RBCXBattery.h\" #include \"RBCXButtons.h\" #include \"RBCXLeds.h\" #include \"RBCXMotor.h\" #include \"RBCXPiezo.h\" #include \"RBCXSmartServo.h\" #include \"RBCXStupidServo.h\" #include \"RBCXTimers.h\" #include \"RBCXUltrasound.h\" #include \"coproc_link_parser.h\" #include \"rbcx.pb.h\" namespace rb { class MotorChangeBuilder ; enum ManagerInstallFlags { MAN_NONE = 0 , MAN_DISABLE_MOTOR_FAILSAFE = ( 1 << 0 ), }; inline ManagerInstallFlags operator | ( ManagerInstallFlags a , ManagerInstallFlags b ) { return static_cast < ManagerInstallFlags > ( static_cast < int > ( a ) | static_cast < int > ( b )); } // Periodically print info about all RBCX tasks to the console //#define RB_DEBUG_MONITOR_TASKS 1 class Manager { friend class MotorChangeBuilder ; friend class Encoder ; friend class PcntInterruptHandler ; friend class Motor ; public : Manager ( Manager const & ) = delete ; void operator = ( Manager const & ) = delete ; static Manager & get () { static Manager instance ; return instance ; } void install ( ManagerInstallFlags flags = MAN_NONE , BaseType_t managerLoopStackSize = 3072 ); //SmartServoBus& initSmartServoBus(uint8_t servo_count); //SmartServoBus& servoBus() { return m_servos; }; Ultrasound & ultrasound ( uint8_t index ) { return m_ultrasounds [ index ]; } StupidServo & stupidServo ( uint8_t index ) { return m_stupidServos [ index ]; } Piezo & piezo () { return m_piezo ; } Battery & battery () { return m_battery ; } Leds & leds () { return m_leds ; } Buttons & buttons () { return m_buttons ; } Motor & motor ( MotorId id ) { return m_motors [ static_cast < int > ( id )]; }; MotorChangeBuilder setMotors (); void schedule ( uint32_t period_ms , std :: function < bool () > callback ) { timers (). schedule ( period_ms , callback ); } inline Timers & timers () { return rb :: Timers :: get (); } // internal api to monitor RBCX tasks void monitorTask ( TaskHandle_t task ); void sendToCoproc ( const CoprocReq & msg ); const CoprocStat_VersionStat & coprocFwVersion () const { return m_coprocFwVersion ; } void coprocFwVersionAssert ( uint32_t minVersion , const char * name ); private : Manager (); ~ Manager (); static void consumerRoutineTrampoline ( void * cookie ); void consumerRoutine (); static void keepaliveRoutine ( void * cookie ); void resetMotorsFailSafe (); bool motorsFailSafe (); #ifdef RB_DEBUG_MONITOR_TASKS bool printTasksDebugInfo (); std :: vector < TaskHandle_t > m_tasks ; std :: mutex m_tasks_mutex ; #endif TaskHandle_t m_keepaliveTask ; CoprocCodec m_codec ; uint8_t m_txBuf [ CoprocCodec :: MaxFrameSize ]; std :: mutex m_codecTxMutex ; uint16_t m_coprocWatchdogTimer ; CoprocStat_VersionStat m_coprocFwVersion ; SemaphoreHandle_t m_coprocSemaphore ; TickType_t m_motors_last_set ; Motor m_motors [ size_t ( MotorId :: MAX )]; rb :: Piezo m_piezo ; rb :: Leds m_leds ; rb :: Buttons m_buttons ; rb :: Battery m_battery ; //rb::SmartServoBus m_servos; rb :: Ultrasound m_ultrasounds [ UltrasoundsCount ]; rb :: StupidServo m_stupidServos [ StupidServosCount ]; }; class MotorChangeBuilder { public : MotorChangeBuilder (); MotorChangeBuilder ( const MotorChangeBuilder & o ) = delete ; MotorChangeBuilder ( MotorChangeBuilder && o ); ~ MotorChangeBuilder (); MotorChangeBuilder & power ( MotorId id , int16_t value ); MotorChangeBuilder & speed ( MotorId id , int16_t ticksPerSecond ); MotorChangeBuilder & brake ( MotorId id , uint16_t brakingPower ); MotorChangeBuilder & pwmMaxPercent ( MotorId id , int8_t percent ); MotorChangeBuilder & drive ( MotorId id , int32_t positionRelative , int16_t speedTicksPerSecond , Motor :: callback_t callback = nullptr ); MotorChangeBuilder & driveToValue ( MotorId id , int32_t positionAbsolute , int16_t speedTicksPerSecond , Motor :: callback_t callback = nullptr ); void set (); private : std :: vector < std :: function < void () >> m_calls ; }; } // namespace rb","title":"File RBCXManager.h"},{"location":"api/RBCXMotor_8cpp/","text":"File RBCXMotor.cpp File List > build > RB3204-RBCX-library > src > RBCXMotor.cpp Go to the source code of this file. #include \"RBCXMotor.h\" #include \"RBCXManager.h\" #include \"rbcx.pb.h\" Namespaces Type Name namespace rb Public Static Attributes Type Name constexpr uint32_t minVersionPositional = = 0x010100 Public Static Attributes Documentation variable minVersionPositional 1 constexpr uint32_t minVersionPositional ; The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXMotor.cpp","title":"File RBCXMotor.cpp"},{"location":"api/RBCXMotor_8cpp/#file-rbcxmotorcpp","text":"File List > build > RB3204-RBCX-library > src > RBCXMotor.cpp Go to the source code of this file. #include \"RBCXMotor.h\" #include \"RBCXManager.h\" #include \"rbcx.pb.h\"","title":"File RBCXMotor.cpp"},{"location":"api/RBCXMotor_8cpp/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXMotor_8cpp/#public-static-attributes","text":"Type Name constexpr uint32_t minVersionPositional = = 0x010100","title":"Public Static Attributes"},{"location":"api/RBCXMotor_8cpp/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"api/RBCXMotor_8cpp/#variable-minversionpositional","text":"1 constexpr uint32_t minVersionPositional ; The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXMotor.cpp","title":"variable minVersionPositional"},{"location":"api/RBCXMotor_8cpp_source/","text":"File RBCXMotor.cpp File List > build > RB3204-RBCX-library > src > RBCXMotor.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 #include \"RBCXMotor.h\" #include \"RBCXManager.h\" #include \"rbcx.pb.h\" static constexpr uint32_t minVersionPositional = 0x010100 ; namespace rb { Motor :: Motor () { m_power = 0 ; m_speed = 0 ; m_position = 0 ; m_mode = MotorMode_POWER ; m_lastReq = CoprocReq_MotorReq_init_zero ; m_pwm_max_percent = 100 ; } void Motor :: requestInfo ( callback_t cb ) { Manager :: get (). coprocFwVersionAssert ( minVersionPositional , \"positional motor control (drive)\" ); std :: lock_guard < std :: mutex > l ( m_mutex ); if ( m_infoCbs . empty ()) { Manager :: get (). sendToCoproc ( CoprocReq { . which_payload = CoprocReq_motorReq_tag , . payload = { . motorReq = CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = CoprocReq_MotorReq_getState_tag , }, }, }); } if ( cb ) { m_infoCbs . emplace_back ( std :: move ( cb )); } } void Motor :: power ( int16_t value ) { sendMotorReq ( CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = CoprocReq_MotorReq_setPower_tag , . motorCmd = { . setPower = scale ( value ), }, }); } void Motor :: speed ( int16_t ticksPerSecond ) { sendMotorReq ( CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = CoprocReq_MotorReq_setVelocity_tag , . motorCmd = { . setVelocity = scale ( ticksPerSecond ), }, }); } void Motor :: brake ( uint16_t value ) { sendMotorReq ( CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = CoprocReq_MotorReq_setBrake_tag , . motorCmd = { . setBrake = value , }, }); } void Motor :: pwmMaxPercent ( int8_t percent ) { m_pwm_max_percent = std :: min ( int8_t ( 100 ), std :: max ( int8_t ( 0 ), percent )); } void Motor :: driveToValue ( int32_t positionAbsolute , int16_t speedTicksPerSecond , callback_t callback ) { Manager :: get (). coprocFwVersionAssert ( minVersionPositional , \"positional motor control (drive)\" ); sendPositionReq ( false , CoprocReq_MotorReq_SetPosition { . targetPosition = positionAbsolute , . runningVelocity = scale ( speedTicksPerSecond ), }, std :: move ( callback )); } void Motor :: drive ( int32_t positionRelative , int16_t speedTicksPerSecond , callback_t callback ) { Manager :: get (). coprocFwVersionAssert ( minVersionPositional , \"positional motor control (drive)\" ); sendPositionReq ( true , CoprocReq_MotorReq_SetPosition { . targetPosition = positionRelative , . runningVelocity = scale ( speedTicksPerSecond ), }, std :: move ( callback )); } void Motor :: setConfig ( const MotorConfig & conf ) { Manager :: get (). coprocFwVersionAssert ( minVersionPositional , \"positional motor control (drive)\" ); const CoprocReq coprocReq = { . which_payload = CoprocReq_motorReq_tag , . payload = { . motorReq = CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = CoprocReq_MotorReq_setConfig_tag , . motorCmd = { . setConfig = conf , }, }, }, }; Manager :: get (). sendToCoproc ( coprocReq ); } void Motor :: setCurrentPosition ( int32_t pos ) { Manager :: get (). coprocFwVersionAssert ( minVersionPositional , \"positional motor control (drive)\" ); std :: lock_guard < std :: mutex > l ( m_mutex ); m_position = pos ; const CoprocReq coprocReq = { . which_payload = CoprocReq_motorReq_tag , . payload = { . motorReq = CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = CoprocReq_MotorReq_homePosition_tag , . motorCmd = { . homePosition = pos , }, }, }, }; Manager :: get (). sendToCoproc ( coprocReq ); } int16_t Motor :: scale ( int16_t val ) { return int32_t ( val ) * m_pwm_max_percent / 100 ; } void Motor :: sendPositionReq ( bool additive , const CoprocReq_MotorReq_SetPosition & req , callback_t && callback ) { { std :: lock_guard < std :: mutex > l ( m_mutex ); Manager :: get (). resetMotorsFailSafe (); memset ( & m_lastReq , 0 , sizeof ( CoprocReq_MotorReq )); m_mode = MotorMode_POSITION ; m_speed = req . runningVelocity ; m_positionCb = callback ; const pb_size_t tag = additive ? CoprocReq_MotorReq_addPosition_tag : CoprocReq_MotorReq_setPosition_tag ; const CoprocReq coprocReq = { . which_payload = CoprocReq_motorReq_tag , . payload = { . motorReq = CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = tag , . motorCmd = { . setPosition = req , }, }, }, }; Manager :: get (). sendToCoproc ( coprocReq ); } } void Motor :: sendMotorReq ( const CoprocReq_MotorReq & req ) { { std :: lock_guard < std :: mutex > l ( m_mutex ); Manager :: get (). resetMotorsFailSafe (); if ( memcmp ( & m_lastReq , & req , sizeof ( CoprocReq_MotorReq )) == 0 ) return ; memcpy ( & m_lastReq , & req , sizeof ( CoprocReq_MotorReq )); switch ( req . which_motorCmd ) { case CoprocReq_MotorReq_setPower_tag : m_mode = MotorMode_POWER ; break ; case CoprocReq_MotorReq_setBrake_tag : m_mode = MotorMode_BRAKE ; break ; case CoprocReq_MotorReq_setVelocity_tag : m_mode = MotorMode_VELOCITY ; break ; default : abort (); } if ( m_mode != MotorMode_POSITION && m_positionCb ) { m_positionCb = nullptr ; } const CoprocReq coprocReq = { . which_payload = CoprocReq_motorReq_tag , . payload = { . motorReq = req , }, }; Manager :: get (). sendToCoproc ( coprocReq ); } } void Motor :: onMotorStat ( const CoprocStat_MotorStat & msg ) { callback_t positionCb ; std :: vector < callback_t > infoCbs ; { std :: lock_guard < std :: mutex > l ( m_mutex ); if ( m_mode == MotorMode_POSITION && msg . mode == MotorMode_POSITION_IDLE && m_positionCb ) { m_positionCb . swap ( positionCb ); } if ( ! m_infoCbs . empty ()) { m_infoCbs . swap ( infoCbs ); } m_mode = msg . mode ; m_position = msg . position ; m_power = msg . power ; m_speed = msg . velocity ; } if ( positionCb ) { positionCb ( * this ); } for ( const auto & cb : infoCbs ) { cb ( * this ); } } }; // namespace rb","title":"File RBCXMotor.cpp"},{"location":"api/RBCXMotor_8cpp_source/#file-rbcxmotorcpp","text":"File List > build > RB3204-RBCX-library > src > RBCXMotor.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 #include \"RBCXMotor.h\" #include \"RBCXManager.h\" #include \"rbcx.pb.h\" static constexpr uint32_t minVersionPositional = 0x010100 ; namespace rb { Motor :: Motor () { m_power = 0 ; m_speed = 0 ; m_position = 0 ; m_mode = MotorMode_POWER ; m_lastReq = CoprocReq_MotorReq_init_zero ; m_pwm_max_percent = 100 ; } void Motor :: requestInfo ( callback_t cb ) { Manager :: get (). coprocFwVersionAssert ( minVersionPositional , \"positional motor control (drive)\" ); std :: lock_guard < std :: mutex > l ( m_mutex ); if ( m_infoCbs . empty ()) { Manager :: get (). sendToCoproc ( CoprocReq { . which_payload = CoprocReq_motorReq_tag , . payload = { . motorReq = CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = CoprocReq_MotorReq_getState_tag , }, }, }); } if ( cb ) { m_infoCbs . emplace_back ( std :: move ( cb )); } } void Motor :: power ( int16_t value ) { sendMotorReq ( CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = CoprocReq_MotorReq_setPower_tag , . motorCmd = { . setPower = scale ( value ), }, }); } void Motor :: speed ( int16_t ticksPerSecond ) { sendMotorReq ( CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = CoprocReq_MotorReq_setVelocity_tag , . motorCmd = { . setVelocity = scale ( ticksPerSecond ), }, }); } void Motor :: brake ( uint16_t value ) { sendMotorReq ( CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = CoprocReq_MotorReq_setBrake_tag , . motorCmd = { . setBrake = value , }, }); } void Motor :: pwmMaxPercent ( int8_t percent ) { m_pwm_max_percent = std :: min ( int8_t ( 100 ), std :: max ( int8_t ( 0 ), percent )); } void Motor :: driveToValue ( int32_t positionAbsolute , int16_t speedTicksPerSecond , callback_t callback ) { Manager :: get (). coprocFwVersionAssert ( minVersionPositional , \"positional motor control (drive)\" ); sendPositionReq ( false , CoprocReq_MotorReq_SetPosition { . targetPosition = positionAbsolute , . runningVelocity = scale ( speedTicksPerSecond ), }, std :: move ( callback )); } void Motor :: drive ( int32_t positionRelative , int16_t speedTicksPerSecond , callback_t callback ) { Manager :: get (). coprocFwVersionAssert ( minVersionPositional , \"positional motor control (drive)\" ); sendPositionReq ( true , CoprocReq_MotorReq_SetPosition { . targetPosition = positionRelative , . runningVelocity = scale ( speedTicksPerSecond ), }, std :: move ( callback )); } void Motor :: setConfig ( const MotorConfig & conf ) { Manager :: get (). coprocFwVersionAssert ( minVersionPositional , \"positional motor control (drive)\" ); const CoprocReq coprocReq = { . which_payload = CoprocReq_motorReq_tag , . payload = { . motorReq = CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = CoprocReq_MotorReq_setConfig_tag , . motorCmd = { . setConfig = conf , }, }, }, }; Manager :: get (). sendToCoproc ( coprocReq ); } void Motor :: setCurrentPosition ( int32_t pos ) { Manager :: get (). coprocFwVersionAssert ( minVersionPositional , \"positional motor control (drive)\" ); std :: lock_guard < std :: mutex > l ( m_mutex ); m_position = pos ; const CoprocReq coprocReq = { . which_payload = CoprocReq_motorReq_tag , . payload = { . motorReq = CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = CoprocReq_MotorReq_homePosition_tag , . motorCmd = { . homePosition = pos , }, }, }, }; Manager :: get (). sendToCoproc ( coprocReq ); } int16_t Motor :: scale ( int16_t val ) { return int32_t ( val ) * m_pwm_max_percent / 100 ; } void Motor :: sendPositionReq ( bool additive , const CoprocReq_MotorReq_SetPosition & req , callback_t && callback ) { { std :: lock_guard < std :: mutex > l ( m_mutex ); Manager :: get (). resetMotorsFailSafe (); memset ( & m_lastReq , 0 , sizeof ( CoprocReq_MotorReq )); m_mode = MotorMode_POSITION ; m_speed = req . runningVelocity ; m_positionCb = callback ; const pb_size_t tag = additive ? CoprocReq_MotorReq_addPosition_tag : CoprocReq_MotorReq_setPosition_tag ; const CoprocReq coprocReq = { . which_payload = CoprocReq_motorReq_tag , . payload = { . motorReq = CoprocReq_MotorReq { . motorIndex = ( uint32_t ) m_id , . which_motorCmd = tag , . motorCmd = { . setPosition = req , }, }, }, }; Manager :: get (). sendToCoproc ( coprocReq ); } } void Motor :: sendMotorReq ( const CoprocReq_MotorReq & req ) { { std :: lock_guard < std :: mutex > l ( m_mutex ); Manager :: get (). resetMotorsFailSafe (); if ( memcmp ( & m_lastReq , & req , sizeof ( CoprocReq_MotorReq )) == 0 ) return ; memcpy ( & m_lastReq , & req , sizeof ( CoprocReq_MotorReq )); switch ( req . which_motorCmd ) { case CoprocReq_MotorReq_setPower_tag : m_mode = MotorMode_POWER ; break ; case CoprocReq_MotorReq_setBrake_tag : m_mode = MotorMode_BRAKE ; break ; case CoprocReq_MotorReq_setVelocity_tag : m_mode = MotorMode_VELOCITY ; break ; default : abort (); } if ( m_mode != MotorMode_POSITION && m_positionCb ) { m_positionCb = nullptr ; } const CoprocReq coprocReq = { . which_payload = CoprocReq_motorReq_tag , . payload = { . motorReq = req , }, }; Manager :: get (). sendToCoproc ( coprocReq ); } } void Motor :: onMotorStat ( const CoprocStat_MotorStat & msg ) { callback_t positionCb ; std :: vector < callback_t > infoCbs ; { std :: lock_guard < std :: mutex > l ( m_mutex ); if ( m_mode == MotorMode_POSITION && msg . mode == MotorMode_POSITION_IDLE && m_positionCb ) { m_positionCb . swap ( positionCb ); } if ( ! m_infoCbs . empty ()) { m_infoCbs . swap ( infoCbs ); } m_mode = msg . mode ; m_position = msg . position ; m_power = msg . power ; m_speed = msg . velocity ; } if ( positionCb ) { positionCb ( * this ); } for ( const auto & cb : infoCbs ) { cb ( * this ); } } }; // namespace rb","title":"File RBCXMotor.cpp"},{"location":"api/RBCXMotor_8h/","text":"File RBCXMotor.h File List > build > RB3204-RBCX-library > src > RBCXMotor.h Go to the source code of this file. #include <atomic> #include <functional> #include <memory> #include <mutex> #include <vector> #include \"RBCXPinout.h\" #include \"RBCXUtil.h\" #include \"rbcx.pb.h\" Namespaces Type Name namespace rb Classes Type Name class Motor The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXMotor.h","title":"File RBCXMotor.h"},{"location":"api/RBCXMotor_8h/#file-rbcxmotorh","text":"File List > build > RB3204-RBCX-library > src > RBCXMotor.h Go to the source code of this file. #include <atomic> #include <functional> #include <memory> #include <mutex> #include <vector> #include \"RBCXPinout.h\" #include \"RBCXUtil.h\" #include \"rbcx.pb.h\"","title":"File RBCXMotor.h"},{"location":"api/RBCXMotor_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXMotor_8h/#classes","text":"Type Name class Motor The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXMotor.h","title":"Classes"},{"location":"api/RBCXMotor_8h_source/","text":"File RBCXMotor.h File List > build > RB3204-RBCX-library > src > RBCXMotor.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #pragma once #include <atomic> #include <functional> #include <memory> #include <mutex> #include <vector> #include \"RBCXPinout.h\" #include \"RBCXUtil.h\" #include \"rbcx.pb.h\" namespace rb { class Manager ; class MotorChangeBuilder ; class Motor { friend class Manager ; friend class MotorChangeBuilder ; public : typedef std :: function < void ( Motor & ) > callback_t ; MotorId id () const { return m_id ; } int32_t position () const { return m_position ; } void requestInfo ( callback_t cb ); void power ( int16_t value ); void speed ( int16_t ticksPerSecond ); void brake ( uint16_t brakingPower ); void pwmMaxPercent ( int8_t percent ); int8_t pwmMaxPercent () const { return m_pwm_max_percent ; } void driveToValue ( int32_t positionAbsolute , int16_t speedTicksPerSecond , callback_t callback = nullptr ); void drive ( int32_t positionRelative , int16_t speedTicksPerSecond , callback_t callback = nullptr ); void setCurrentPosition ( int32_t pos = 0 ); void setConfig ( const MotorConfig & cfg ); private : Motor (); Motor ( const Motor & ) = delete ; void setId ( MotorId id ) { m_id = id ; } void sendPositionReq ( bool additive , const CoprocReq_MotorReq_SetPosition & req , callback_t && callback ); void sendMotorReq ( const CoprocReq_MotorReq & req ); void onMotorStat ( const CoprocStat_MotorStat & msg ); int16_t scale ( int16_t val ); callback_t m_positionCb ; std :: vector < callback_t > m_infoCbs ; CoprocReq_MotorReq m_lastReq ; std :: mutex m_mutex ; MotorId m_id ; MotorMode m_mode ; int32_t m_position ; int16_t m_power ; int16_t m_speed ; int8_t m_pwm_max_percent ; }; } // namespace rb","title":"File RBCXMotor.h"},{"location":"api/RBCXMotor_8h_source/#file-rbcxmotorh","text":"File List > build > RB3204-RBCX-library > src > RBCXMotor.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #pragma once #include <atomic> #include <functional> #include <memory> #include <mutex> #include <vector> #include \"RBCXPinout.h\" #include \"RBCXUtil.h\" #include \"rbcx.pb.h\" namespace rb { class Manager ; class MotorChangeBuilder ; class Motor { friend class Manager ; friend class MotorChangeBuilder ; public : typedef std :: function < void ( Motor & ) > callback_t ; MotorId id () const { return m_id ; } int32_t position () const { return m_position ; } void requestInfo ( callback_t cb ); void power ( int16_t value ); void speed ( int16_t ticksPerSecond ); void brake ( uint16_t brakingPower ); void pwmMaxPercent ( int8_t percent ); int8_t pwmMaxPercent () const { return m_pwm_max_percent ; } void driveToValue ( int32_t positionAbsolute , int16_t speedTicksPerSecond , callback_t callback = nullptr ); void drive ( int32_t positionRelative , int16_t speedTicksPerSecond , callback_t callback = nullptr ); void setCurrentPosition ( int32_t pos = 0 ); void setConfig ( const MotorConfig & cfg ); private : Motor (); Motor ( const Motor & ) = delete ; void setId ( MotorId id ) { m_id = id ; } void sendPositionReq ( bool additive , const CoprocReq_MotorReq_SetPosition & req , callback_t && callback ); void sendMotorReq ( const CoprocReq_MotorReq & req ); void onMotorStat ( const CoprocStat_MotorStat & msg ); int16_t scale ( int16_t val ); callback_t m_positionCb ; std :: vector < callback_t > m_infoCbs ; CoprocReq_MotorReq m_lastReq ; std :: mutex m_mutex ; MotorId m_id ; MotorMode m_mode ; int32_t m_position ; int16_t m_power ; int16_t m_speed ; int8_t m_pwm_max_percent ; }; } // namespace rb","title":"File RBCXMotor.h"},{"location":"api/RBCXNvs_8cpp/","text":"File RBCXNvs.cpp File List > build > RB3204-RBCX-library > src > RBCXNvs.cpp Go to the source code of this file. #include <vector> #include \"RBCXNvs.h\" Namespaces Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXNvs.cpp","title":"File RBCXNvs.cpp"},{"location":"api/RBCXNvs_8cpp/#file-rbcxnvscpp","text":"File List > build > RB3204-RBCX-library > src > RBCXNvs.cpp Go to the source code of this file. #include <vector> #include \"RBCXNvs.h\"","title":"File RBCXNvs.cpp"},{"location":"api/RBCXNvs_8cpp/#namespaces","text":"Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXNvs.cpp","title":"Namespaces"},{"location":"api/RBCXNvs_8cpp_source/","text":"File RBCXNvs.cpp File List > build > RB3204-RBCX-library > src > RBCXNvs.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include <vector> #include \"RBCXNvs.h\" namespace rb { Nvs :: Nvs ( const char * name , const char * partiton ) : m_dirty ( false ) { ESP_ERROR_CHECK ( initFlash ()); ESP_ERROR_CHECK ( nvs_open_from_partition ( partiton , name , NVS_READWRITE , & m_handle )); } Nvs ::~ Nvs () { if ( m_dirty ) commit (); nvs_close ( m_handle ); } esp_err_t Nvs :: initFlash () { esp_err_t err = nvs_flash_init (); if ( err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND ) { // NVS partition was truncated and needs to be erased // Retry nvs_flash_init ESP_ERROR_CHECK ( nvs_flash_erase ()); err = nvs_flash_init (); } return err ; } bool Nvs :: existsInt ( const char * key ) { int value ; return nvs_get_i32 ( m_handle , key , & value ) == ESP_OK ; } int Nvs :: getInt ( const char * key ) { int value ; ESP_ERROR_CHECK ( nvs_get_i32 ( m_handle , key , & value )); return value ; } void Nvs :: writeInt ( const char * key , int value ) { ESP_ERROR_CHECK ( nvs_set_i32 ( m_handle , key , value )); m_dirty = true ; } bool Nvs :: existsString ( const char * key ) { size_t len ; return nvs_get_str ( m_handle , key , NULL , & len ) == ESP_OK ; } std :: string Nvs :: getString ( const char * key ) { size_t len ; ESP_ERROR_CHECK ( nvs_get_str ( m_handle , key , NULL , & len )); std :: vector < char > res ( len , ' ' ); ESP_ERROR_CHECK ( nvs_get_str ( m_handle , key , res . data (), & len )); return std :: string ( res . data ()); } void Nvs :: writeString ( const char * key , const std :: string & value ) { ESP_ERROR_CHECK ( nvs_set_str ( m_handle , key , value . c_str ())); m_dirty = true ; } void Nvs :: commit () { nvs_commit ( m_handle ); m_dirty = false ; } } // namespace rb","title":"File RBCXNvs.cpp"},{"location":"api/RBCXNvs_8cpp_source/#file-rbcxnvscpp","text":"File List > build > RB3204-RBCX-library > src > RBCXNvs.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include <vector> #include \"RBCXNvs.h\" namespace rb { Nvs :: Nvs ( const char * name , const char * partiton ) : m_dirty ( false ) { ESP_ERROR_CHECK ( initFlash ()); ESP_ERROR_CHECK ( nvs_open_from_partition ( partiton , name , NVS_READWRITE , & m_handle )); } Nvs ::~ Nvs () { if ( m_dirty ) commit (); nvs_close ( m_handle ); } esp_err_t Nvs :: initFlash () { esp_err_t err = nvs_flash_init (); if ( err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND ) { // NVS partition was truncated and needs to be erased // Retry nvs_flash_init ESP_ERROR_CHECK ( nvs_flash_erase ()); err = nvs_flash_init (); } return err ; } bool Nvs :: existsInt ( const char * key ) { int value ; return nvs_get_i32 ( m_handle , key , & value ) == ESP_OK ; } int Nvs :: getInt ( const char * key ) { int value ; ESP_ERROR_CHECK ( nvs_get_i32 ( m_handle , key , & value )); return value ; } void Nvs :: writeInt ( const char * key , int value ) { ESP_ERROR_CHECK ( nvs_set_i32 ( m_handle , key , value )); m_dirty = true ; } bool Nvs :: existsString ( const char * key ) { size_t len ; return nvs_get_str ( m_handle , key , NULL , & len ) == ESP_OK ; } std :: string Nvs :: getString ( const char * key ) { size_t len ; ESP_ERROR_CHECK ( nvs_get_str ( m_handle , key , NULL , & len )); std :: vector < char > res ( len , ' ' ); ESP_ERROR_CHECK ( nvs_get_str ( m_handle , key , res . data (), & len )); return std :: string ( res . data ()); } void Nvs :: writeString ( const char * key , const std :: string & value ) { ESP_ERROR_CHECK ( nvs_set_str ( m_handle , key , value . c_str ())); m_dirty = true ; } void Nvs :: commit () { nvs_commit ( m_handle ); m_dirty = false ; } } // namespace rb","title":"File RBCXNvs.cpp"},{"location":"api/RBCXNvs_8h/","text":"File RBCXNvs.h File List > build > RB3204-RBCX-library > src > RBCXNvs.h Go to the source code of this file. #include <string> #include <esp_system.h> #include <nvs.h> #include <nvs_flash.h> Namespaces Type Name namespace rb Classes Type Name class Nvs The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXNvs.h","title":"File RBCXNvs.h"},{"location":"api/RBCXNvs_8h/#file-rbcxnvsh","text":"File List > build > RB3204-RBCX-library > src > RBCXNvs.h Go to the source code of this file. #include <string> #include <esp_system.h> #include <nvs.h> #include <nvs_flash.h>","title":"File RBCXNvs.h"},{"location":"api/RBCXNvs_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXNvs_8h/#classes","text":"Type Name class Nvs The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXNvs.h","title":"Classes"},{"location":"api/RBCXNvs_8h_source/","text":"File RBCXNvs.h File List > build > RB3204-RBCX-library > src > RBCXNvs.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #pragma once #include <string> #include <esp_system.h> #include <nvs.h> #include <nvs_flash.h> namespace rb { class Nvs { public : Nvs ( const char * name_space , const char * partition = \"nvs\" ); ~ Nvs (); Nvs ( const Nvs & ) = delete ; bool existsInt ( const char * key ); int getInt ( const char * key ); void writeInt ( const char * key , int value ); bool existsString ( const char * key ); std :: string getString ( const char * key ); void writeString ( const char * key , const std :: string & value ); void commit (); private : esp_err_t initFlash (); nvs_handle m_handle ; bool m_dirty ; }; } // namespace rb","title":"File RBCXNvs.h"},{"location":"api/RBCXNvs_8h_source/#file-rbcxnvsh","text":"File List > build > RB3204-RBCX-library > src > RBCXNvs.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #pragma once #include <string> #include <esp_system.h> #include <nvs.h> #include <nvs_flash.h> namespace rb { class Nvs { public : Nvs ( const char * name_space , const char * partition = \"nvs\" ); ~ Nvs (); Nvs ( const Nvs & ) = delete ; bool existsInt ( const char * key ); int getInt ( const char * key ); void writeInt ( const char * key , int value ); bool existsString ( const char * key ); std :: string getString ( const char * key ); void writeString ( const char * key , const std :: string & value ); void commit (); private : esp_err_t initFlash (); nvs_handle m_handle ; bool m_dirty ; }; } // namespace rb","title":"File RBCXNvs.h"},{"location":"api/RBCXPiezo_8cpp/","text":"File RBCXPiezo.cpp File List > build > RB3204-RBCX-library > src > RBCXPiezo.cpp Go to the source code of this file. #include <driver/gpio.h> #include <driver/ledc.h> #include <esp_log.h> #include \"RBCXManager.h\" #include \"RBCXPiezo.h\" #include \"rbcx.pb.h\" Namespaces Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXPiezo.cpp","title":"File RBCXPiezo.cpp"},{"location":"api/RBCXPiezo_8cpp/#file-rbcxpiezocpp","text":"File List > build > RB3204-RBCX-library > src > RBCXPiezo.cpp Go to the source code of this file. #include <driver/gpio.h> #include <driver/ledc.h> #include <esp_log.h> #include \"RBCXManager.h\" #include \"RBCXPiezo.h\" #include \"rbcx.pb.h\"","title":"File RBCXPiezo.cpp"},{"location":"api/RBCXPiezo_8cpp/#namespaces","text":"Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXPiezo.cpp","title":"Namespaces"},{"location":"api/RBCXPiezo_8cpp_source/","text":"File RBCXPiezo.cpp File List > build > RB3204-RBCX-library > src > RBCXPiezo.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <driver/gpio.h> #include <driver/ledc.h> #include <esp_log.h> #include \"RBCXManager.h\" #include \"RBCXPiezo.h\" #include \"rbcx.pb.h\" namespace rb { Piezo :: Piezo () : m_on ( false ) {} Piezo ::~ Piezo () {} void Piezo :: setState ( bool on ) { if ( m_on == on ) return ; m_on = on ; Manager :: get (). sendToCoproc ( CoprocReq { . which_payload = CoprocReq_buzzerReq_tag , . payload = { . buzzerReq = { . on = on , } } }); } };","title":"File RBCXPiezo.cpp"},{"location":"api/RBCXPiezo_8cpp_source/#file-rbcxpiezocpp","text":"File List > build > RB3204-RBCX-library > src > RBCXPiezo.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <driver/gpio.h> #include <driver/ledc.h> #include <esp_log.h> #include \"RBCXManager.h\" #include \"RBCXPiezo.h\" #include \"rbcx.pb.h\" namespace rb { Piezo :: Piezo () : m_on ( false ) {} Piezo ::~ Piezo () {} void Piezo :: setState ( bool on ) { if ( m_on == on ) return ; m_on = on ; Manager :: get (). sendToCoproc ( CoprocReq { . which_payload = CoprocReq_buzzerReq_tag , . payload = { . buzzerReq = { . on = on , } } }); } };","title":"File RBCXPiezo.cpp"},{"location":"api/RBCXPiezo_8h/","text":"File RBCXPiezo.h File List > build > RB3204-RBCX-library > src > RBCXPiezo.h Go to the source code of this file. #include <atomic> Namespaces Type Name namespace rb Classes Type Name class Piezo Helper class for controlling the piezo. The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXPiezo.h","title":"File RBCXPiezo.h"},{"location":"api/RBCXPiezo_8h/#file-rbcxpiezoh","text":"File List > build > RB3204-RBCX-library > src > RBCXPiezo.h Go to the source code of this file. #include <atomic>","title":"File RBCXPiezo.h"},{"location":"api/RBCXPiezo_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXPiezo_8h/#classes","text":"Type Name class Piezo Helper class for controlling the piezo. The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXPiezo.h","title":"Classes"},{"location":"api/RBCXPiezo_8h_source/","text":"File RBCXPiezo.h File List > build > RB3204-RBCX-library > src > RBCXPiezo.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #pragma once #include <atomic> namespace rb { class Piezo { friend class Manager ; public : void start () { setState ( true ); } void stop () { setState ( false ); } void setState ( bool on ); private : Piezo (); Piezo ( const Piezo & ) = delete ; ~ Piezo (); bool m_on ; }; };","title":"File RBCXPiezo.h"},{"location":"api/RBCXPiezo_8h_source/#file-rbcxpiezoh","text":"File List > build > RB3204-RBCX-library > src > RBCXPiezo.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #pragma once #include <atomic> namespace rb { class Piezo { friend class Manager ; public : void start () { setState ( true ); } void stop () { setState ( false ); } void setState ( bool on ); private : Piezo (); Piezo ( const Piezo & ) = delete ; ~ Piezo (); bool m_on ; }; };","title":"File RBCXPiezo.h"},{"location":"api/RBCXPinout_8h/","text":"File RBCXPinout.h File List > build > RB3204-RBCX-library > src > RBCXPinout.h Go to the source code of this file. #include <driver/adc.h> #include <driver/gpio.h> Namespaces Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXPinout.h","title":"File RBCXPinout.h"},{"location":"api/RBCXPinout_8h/#file-rbcxpinouth","text":"File List > build > RB3204-RBCX-library > src > RBCXPinout.h Go to the source code of this file. #include <driver/adc.h> #include <driver/gpio.h>","title":"File RBCXPinout.h"},{"location":"api/RBCXPinout_8h/#namespaces","text":"Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXPinout.h","title":"Namespaces"},{"location":"api/RBCXPinout_8h_source/","text":"File RBCXPinout.h File List > build > RB3204-RBCX-library > src > RBCXPinout.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #pragma once #include <driver/adc.h> #include <driver/gpio.h> namespace rb { enum class MotorId : uint8_t { M1 , M2 , M3 , M4 , MAX , }; inline MotorId operator ++ ( MotorId & x ) { return x = MotorId ( static_cast < uint8_t > ( x ) + 1 ); } static constexpr int UltrasoundsCount = 4 ; static constexpr int StupidServosCount = 4 ; } // namespace rb","title":"File RBCXPinout.h"},{"location":"api/RBCXPinout_8h_source/#file-rbcxpinouth","text":"File List > build > RB3204-RBCX-library > src > RBCXPinout.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #pragma once #include <driver/adc.h> #include <driver/gpio.h> namespace rb { enum class MotorId : uint8_t { M1 , M2 , M3 , M4 , MAX , }; inline MotorId operator ++ ( MotorId & x ) { return x = MotorId ( static_cast < uint8_t > ( x ) + 1 ); } static constexpr int UltrasoundsCount = 4 ; static constexpr int StupidServosCount = 4 ; } // namespace rb","title":"File RBCXPinout.h"},{"location":"api/RBCXSmartServo_8cpp/","text":"File RBCXSmartServo.cpp File List > build > RB3204-RBCX-library > src > RBCXSmartServo.cpp Go to the source code of this file. #include <algorithm> #include <chrono> #include <esp_log.h> #include <freertos/FreeRTOS.h> #include <freertos/task.h> #include <math.h> #include \"RBCXManager.h\" #include \"RBCXSmartServo.h\" Namespaces Type Name namespace rb Macros Type Name define MS_TO_TICKS (ms) ((portTICK_PERIOD_MS <= ms) ? (ms / portTICK_PERIOD_MS) : 1) define TAG \"RBCXSmartServoBus\" Macro Definition Documentation define MS_TO_TICKS 1 2 3 #define MS_TO_TICKS ( ms ) (( portTICK_PERIOD_MS <= ms ) ? ( ms / portTICK_PERIOD_MS ) : 1 ) define TAG 1 #define TAG \"RBCXSmartServoBus\" The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXSmartServo.cpp","title":"File RBCXSmartServo.cpp"},{"location":"api/RBCXSmartServo_8cpp/#file-rbcxsmartservocpp","text":"File List > build > RB3204-RBCX-library > src > RBCXSmartServo.cpp Go to the source code of this file. #include <algorithm> #include <chrono> #include <esp_log.h> #include <freertos/FreeRTOS.h> #include <freertos/task.h> #include <math.h> #include \"RBCXManager.h\" #include \"RBCXSmartServo.h\"","title":"File RBCXSmartServo.cpp"},{"location":"api/RBCXSmartServo_8cpp/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXSmartServo_8cpp/#macros","text":"Type Name define MS_TO_TICKS (ms) ((portTICK_PERIOD_MS <= ms) ? (ms / portTICK_PERIOD_MS) : 1) define TAG \"RBCXSmartServoBus\"","title":"Macros"},{"location":"api/RBCXSmartServo_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"api/RBCXSmartServo_8cpp/#define-ms_to_ticks","text":"1 2 3 #define MS_TO_TICKS ( ms ) (( portTICK_PERIOD_MS <= ms ) ? ( ms / portTICK_PERIOD_MS ) : 1 )","title":"define MS_TO_TICKS"},{"location":"api/RBCXSmartServo_8cpp/#define-tag","text":"1 #define TAG \"RBCXSmartServoBus\" The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXSmartServo.cpp","title":"define TAG"},{"location":"api/RBCXSmartServo_8cpp_source/","text":"File RBCXSmartServo.cpp File List > build > RB3204-RBCX-library > src > RBCXSmartServo.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 #include <algorithm> #include <chrono> #include <esp_log.h> #include <freertos/FreeRTOS.h> #include <freertos/task.h> #include <math.h> #include \"RBCXManager.h\" #include \"RBCXSmartServo.h\" #define TAG \"RBCXSmartServoBus\" #define MS_TO_TICKS(ms) \\ ((portTICK_PERIOD_MS <= ms) ? (ms / portTICK_PERIOD_MS) : 1) namespace rb { SmartServoBus :: SmartServoBus () {} void SmartServoBus :: install ( uint8_t servo_count ) { if ( ! m_servos . empty () || servo_count == 0 ) return ; m_servos . resize ( servo_count ); TaskHandle_t task ; xTaskCreate ( & SmartServoBus :: regulatorRoutineTrampoline , \"rbservo_reg\" , 1536 , this , 2 , & task ); Manager :: get (). monitorTask ( task ); Angle val ; for ( uint8_t i = 0 ; i < servo_count ; ++ i ) { for ( int x = 0 ; x < 3 ; ++ x ) { val = pos ( i ); if ( ! val . isNaN ()) { break ; } else { ESP_LOGW ( TAG , \"failed to read servo %d pos, attempt %d\" , i , x + 1 ); } } if ( val . isNaN ()) { ESP_LOGE ( TAG , \"failed to read position from servo %d, it will not work!\" , i ); continue ; } const uint16_t deg_val = 100 * val . deg (); m_mutex . lock (); m_servos [ i ]. current = deg_val ; m_servos [ i ]. target = deg_val ; m_mutex . unlock (); } } void SmartServoBus :: setId ( uint8_t newId , uint8_t destId ) { // TODO } uint8_t SmartServoBus :: getId ( uint8_t destId ) { // TODO return 0 ; } void SmartServoBus :: set ( uint8_t id , Angle ang , float speed , float speed_raise ) { speed = std :: max ( 1.f , std :: min ( 240.f , speed )) / 10.f ; const uint16_t angle = std :: max ( 0.f , std :: min ( 360.f , ( float ) ang . deg ())) * 100 ; std :: lock_guard < std :: mutex > lock ( m_mutex ); auto & si = m_servos [ id ]; if ( ! si . hasValidCurrent ()) { const auto cur = pos ( id ); if ( cur . isNaN ()) { ESP_LOGE ( TAG , \"failed to get servo %d position, can't move it!\" , int ( id )); return ; } const uint16_t deg_val = 100 * cur . deg (); si . current = deg_val ; si . target = deg_val ; } if ( si . current == angle ) return ; if (( si . current > si . target ) != ( si . current > angle )) { si . speed_coef = 0.f ; } si . target = angle ; si . speed_target = speed ; si . speed_raise = speed_raise ; } Angle SmartServoBus :: pos ( uint8_t id ) { // TODO return Angle :: deg ( 0 ); } Angle SmartServoBus :: posOffline ( uint8_t id ) { std :: lock_guard < std :: mutex > lock ( m_mutex ); auto & s = m_servos [ id ]; if ( s . current == 0xFFFF ) return Angle :: nan (); return Angle :: deg ( Angle :: _T ( s . current ) / 100.f ); } void SmartServoBus :: limit ( uint8_t id , Angle bottom , Angle top ) { // TODO } void SmartServoBus :: setAutoStop ( uint8_t id , bool enable ) { m_mutex . lock (); m_servos [ id ]. auto_stop = enable ; m_mutex . unlock (); } void SmartServoBus :: regulatorRoutineTrampoline ( void * cookie ) { (( SmartServoBus * ) cookie ) -> regulatorRoutine (); } void SmartServoBus :: regulatorRoutine () { const size_t servos_cnt = m_servos . size (); constexpr uint32_t msPerServo = 30 ; constexpr auto ticksPerServo = MS_TO_TICKS ( msPerServo ); const uint32_t msPerIter = servos_cnt * msPerServo ; const auto ticksPerIter = MS_TO_TICKS ( msPerIter ); // TODO auto queue = xQueueCreate ( 1 , 4 /*sizeof(struct rx_response)*/ ); while ( true ) { const auto tm_iter_start = xTaskGetTickCount (); for ( size_t i = 0 ; i < servos_cnt ; ++ i ) { const auto tm_servo_start = xTaskGetTickCount (); regulateServo ( queue , i , msPerIter ); const auto diff = xTaskGetTickCount () - tm_servo_start ; if ( diff < ticksPerServo ) { vTaskDelay ( ticksPerServo - diff ); } } const auto diff = xTaskGetTickCount () - tm_iter_start ; if ( diff < ticksPerIter ) { vTaskDelay ( ticksPerIter - diff ); } } } bool SmartServoBus :: regulateServo ( QueueHandle_t responseQueue , size_t id , uint32_t timeSliceMs ) { float move_pos_deg ; auto & s = m_servos [ id ]; { std :: lock_guard < std :: mutex > lock ( m_mutex ); if ( s . auto_stop ) { // TODO /*lw::Packet pos_req(id, lw::Command::SERVO_POS_READ); send(pos_req, responseQueue, true); xQueueReceive(responseQueue, &resp, portMAX_DELAY); if (resp.size == 0x08) { const float val = (float)((resp.data[6] << 8) | resp.data[5]); const int val_int = (val / 1000.f) * 24000.f; const int diff = val_int - int(s.current); if (abs(diff) > 300) { if (++s.auto_stop_counter > 5) { s.target = val_int + (diff > 0 ? -200 : 200); s.auto_stop_counter = 0; } } else if (s.auto_stop_counter != 0) { s.auto_stop_counter = 0; } }*/ } if ( s . current == s . target ) { return false ; } float speed = s . speed_target ; if ( s . speed_coef < 1.f ) { s . speed_coef = std :: min ( 1.f , s . speed_coef + ( s . speed_raise * timeSliceMs )); speed *= ( s . speed_coef * s . speed_coef ); } int32_t dist = abs ( int32_t ( s . target ) - int32_t ( s . current )); dist = std :: max ( 1 , std :: min ( dist , int32_t ( speed * timeSliceMs ))); if ( dist > 0 ) { if ( s . target < s . current ) { s . current -= dist ; } else { s . current += dist ; } } if ( dist <= 0 || s . current == s . target ) { s . current = s . target ; s . speed_coef = 0.f ; } move_pos_deg = float ( s . current ) / 100.f ; } // TODO /*const auto pkt = lw::Servo::move(id, Angle::deg(move_pos_deg), std::chrono::milliseconds(timeSliceMs - 5)); send(pkt, responseQueue, false, true); if (xQueueReceive(responseQueue, &resp, 500 / portTICK_PERIOD_MS) != pdTRUE) { ESP_LOGE(TAG, \"Response to move packet not received!\"); }*/ return true ; } }; // namespace rb","title":"File RBCXSmartServo.cpp"},{"location":"api/RBCXSmartServo_8cpp_source/#file-rbcxsmartservocpp","text":"File List > build > RB3204-RBCX-library > src > RBCXSmartServo.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 #include <algorithm> #include <chrono> #include <esp_log.h> #include <freertos/FreeRTOS.h> #include <freertos/task.h> #include <math.h> #include \"RBCXManager.h\" #include \"RBCXSmartServo.h\" #define TAG \"RBCXSmartServoBus\" #define MS_TO_TICKS(ms) \\ ((portTICK_PERIOD_MS <= ms) ? (ms / portTICK_PERIOD_MS) : 1) namespace rb { SmartServoBus :: SmartServoBus () {} void SmartServoBus :: install ( uint8_t servo_count ) { if ( ! m_servos . empty () || servo_count == 0 ) return ; m_servos . resize ( servo_count ); TaskHandle_t task ; xTaskCreate ( & SmartServoBus :: regulatorRoutineTrampoline , \"rbservo_reg\" , 1536 , this , 2 , & task ); Manager :: get (). monitorTask ( task ); Angle val ; for ( uint8_t i = 0 ; i < servo_count ; ++ i ) { for ( int x = 0 ; x < 3 ; ++ x ) { val = pos ( i ); if ( ! val . isNaN ()) { break ; } else { ESP_LOGW ( TAG , \"failed to read servo %d pos, attempt %d\" , i , x + 1 ); } } if ( val . isNaN ()) { ESP_LOGE ( TAG , \"failed to read position from servo %d, it will not work!\" , i ); continue ; } const uint16_t deg_val = 100 * val . deg (); m_mutex . lock (); m_servos [ i ]. current = deg_val ; m_servos [ i ]. target = deg_val ; m_mutex . unlock (); } } void SmartServoBus :: setId ( uint8_t newId , uint8_t destId ) { // TODO } uint8_t SmartServoBus :: getId ( uint8_t destId ) { // TODO return 0 ; } void SmartServoBus :: set ( uint8_t id , Angle ang , float speed , float speed_raise ) { speed = std :: max ( 1.f , std :: min ( 240.f , speed )) / 10.f ; const uint16_t angle = std :: max ( 0.f , std :: min ( 360.f , ( float ) ang . deg ())) * 100 ; std :: lock_guard < std :: mutex > lock ( m_mutex ); auto & si = m_servos [ id ]; if ( ! si . hasValidCurrent ()) { const auto cur = pos ( id ); if ( cur . isNaN ()) { ESP_LOGE ( TAG , \"failed to get servo %d position, can't move it!\" , int ( id )); return ; } const uint16_t deg_val = 100 * cur . deg (); si . current = deg_val ; si . target = deg_val ; } if ( si . current == angle ) return ; if (( si . current > si . target ) != ( si . current > angle )) { si . speed_coef = 0.f ; } si . target = angle ; si . speed_target = speed ; si . speed_raise = speed_raise ; } Angle SmartServoBus :: pos ( uint8_t id ) { // TODO return Angle :: deg ( 0 ); } Angle SmartServoBus :: posOffline ( uint8_t id ) { std :: lock_guard < std :: mutex > lock ( m_mutex ); auto & s = m_servos [ id ]; if ( s . current == 0xFFFF ) return Angle :: nan (); return Angle :: deg ( Angle :: _T ( s . current ) / 100.f ); } void SmartServoBus :: limit ( uint8_t id , Angle bottom , Angle top ) { // TODO } void SmartServoBus :: setAutoStop ( uint8_t id , bool enable ) { m_mutex . lock (); m_servos [ id ]. auto_stop = enable ; m_mutex . unlock (); } void SmartServoBus :: regulatorRoutineTrampoline ( void * cookie ) { (( SmartServoBus * ) cookie ) -> regulatorRoutine (); } void SmartServoBus :: regulatorRoutine () { const size_t servos_cnt = m_servos . size (); constexpr uint32_t msPerServo = 30 ; constexpr auto ticksPerServo = MS_TO_TICKS ( msPerServo ); const uint32_t msPerIter = servos_cnt * msPerServo ; const auto ticksPerIter = MS_TO_TICKS ( msPerIter ); // TODO auto queue = xQueueCreate ( 1 , 4 /*sizeof(struct rx_response)*/ ); while ( true ) { const auto tm_iter_start = xTaskGetTickCount (); for ( size_t i = 0 ; i < servos_cnt ; ++ i ) { const auto tm_servo_start = xTaskGetTickCount (); regulateServo ( queue , i , msPerIter ); const auto diff = xTaskGetTickCount () - tm_servo_start ; if ( diff < ticksPerServo ) { vTaskDelay ( ticksPerServo - diff ); } } const auto diff = xTaskGetTickCount () - tm_iter_start ; if ( diff < ticksPerIter ) { vTaskDelay ( ticksPerIter - diff ); } } } bool SmartServoBus :: regulateServo ( QueueHandle_t responseQueue , size_t id , uint32_t timeSliceMs ) { float move_pos_deg ; auto & s = m_servos [ id ]; { std :: lock_guard < std :: mutex > lock ( m_mutex ); if ( s . auto_stop ) { // TODO /*lw::Packet pos_req(id, lw::Command::SERVO_POS_READ); send(pos_req, responseQueue, true); xQueueReceive(responseQueue, &resp, portMAX_DELAY); if (resp.size == 0x08) { const float val = (float)((resp.data[6] << 8) | resp.data[5]); const int val_int = (val / 1000.f) * 24000.f; const int diff = val_int - int(s.current); if (abs(diff) > 300) { if (++s.auto_stop_counter > 5) { s.target = val_int + (diff > 0 ? -200 : 200); s.auto_stop_counter = 0; } } else if (s.auto_stop_counter != 0) { s.auto_stop_counter = 0; } }*/ } if ( s . current == s . target ) { return false ; } float speed = s . speed_target ; if ( s . speed_coef < 1.f ) { s . speed_coef = std :: min ( 1.f , s . speed_coef + ( s . speed_raise * timeSliceMs )); speed *= ( s . speed_coef * s . speed_coef ); } int32_t dist = abs ( int32_t ( s . target ) - int32_t ( s . current )); dist = std :: max ( 1 , std :: min ( dist , int32_t ( speed * timeSliceMs ))); if ( dist > 0 ) { if ( s . target < s . current ) { s . current -= dist ; } else { s . current += dist ; } } if ( dist <= 0 || s . current == s . target ) { s . current = s . target ; s . speed_coef = 0.f ; } move_pos_deg = float ( s . current ) / 100.f ; } // TODO /*const auto pkt = lw::Servo::move(id, Angle::deg(move_pos_deg), std::chrono::milliseconds(timeSliceMs - 5)); send(pkt, responseQueue, false, true); if (xQueueReceive(responseQueue, &resp, 500 / portTICK_PERIOD_MS) != pdTRUE) { ESP_LOGE(TAG, \"Response to move packet not received!\"); }*/ return true ; } }; // namespace rb","title":"File RBCXSmartServo.cpp"},{"location":"api/RBCXSmartServo_8h/","text":"File RBCXSmartServo.h File List > build > RB3204-RBCX-library > src > RBCXSmartServo.h Go to the source code of this file. #include <FreeRTOS.h> #include <mutex> #include <vector> #include \"RBCXAngle.h\" #include \"RBCXUtil.h\" Namespaces Type Name namespace rb Classes Type Name class SmartServoBus The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXSmartServo.h","title":"File RBCXSmartServo.h"},{"location":"api/RBCXSmartServo_8h/#file-rbcxsmartservoh","text":"File List > build > RB3204-RBCX-library > src > RBCXSmartServo.h Go to the source code of this file. #include <FreeRTOS.h> #include <mutex> #include <vector> #include \"RBCXAngle.h\" #include \"RBCXUtil.h\"","title":"File RBCXSmartServo.h"},{"location":"api/RBCXSmartServo_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXSmartServo_8h/#classes","text":"Type Name class SmartServoBus The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXSmartServo.h","title":"Classes"},{"location":"api/RBCXSmartServo_8h_source/","text":"File RBCXSmartServo.h File List > build > RB3204-RBCX-library > src > RBCXSmartServo.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #pragma once #include <FreeRTOS.h> #include <mutex> #include <vector> #include \"RBCXAngle.h\" #include \"RBCXUtil.h\" namespace rb { class Manager ; class Encoder ; class SmartServoBus { friend class Manager ; public : SmartServoBus (); ~ SmartServoBus () {} void set ( uint8_t id , Angle ang , float speed = 180.f , float speed_raise = 0.0015f ); void limit ( uint8_t id , Angle bottom , Angle top ); Angle pos ( uint8_t id ); Angle posOffline ( uint8_t id ); void setAutoStop ( uint8_t id , bool enable = true ); void setId ( uint8_t newId , uint8_t destId = 254 ); uint8_t getId ( uint8_t destId = 254 ); private : SmartServoBus ( const SmartServoBus & ) = delete ; void install ( uint8_t servo_count ); static void regulatorRoutineTrampoline ( void * cookie ); void regulatorRoutine (); bool regulateServo ( QueueHandle_t responseQueue , size_t id , uint32_t timeSliceMs ); struct servo_info { servo_info () { current = 0xFFFF ; target = 0xFFFF ; speed_coef = 0.f ; speed_target = 0.f ; speed_raise = 0.f ; auto_stop = false ; auto_stop_counter = 0 ; } bool hasValidCurrent () const { return current != 0xFFFF ; } float speed_coef ; float speed_target ; float speed_raise ; uint16_t current ; uint16_t target ; bool auto_stop ; uint8_t auto_stop_counter ; }; std :: vector < servo_info > m_servos ; std :: mutex m_mutex ; }; };","title":"File RBCXSmartServo.h"},{"location":"api/RBCXSmartServo_8h_source/#file-rbcxsmartservoh","text":"File List > build > RB3204-RBCX-library > src > RBCXSmartServo.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #pragma once #include <FreeRTOS.h> #include <mutex> #include <vector> #include \"RBCXAngle.h\" #include \"RBCXUtil.h\" namespace rb { class Manager ; class Encoder ; class SmartServoBus { friend class Manager ; public : SmartServoBus (); ~ SmartServoBus () {} void set ( uint8_t id , Angle ang , float speed = 180.f , float speed_raise = 0.0015f ); void limit ( uint8_t id , Angle bottom , Angle top ); Angle pos ( uint8_t id ); Angle posOffline ( uint8_t id ); void setAutoStop ( uint8_t id , bool enable = true ); void setId ( uint8_t newId , uint8_t destId = 254 ); uint8_t getId ( uint8_t destId = 254 ); private : SmartServoBus ( const SmartServoBus & ) = delete ; void install ( uint8_t servo_count ); static void regulatorRoutineTrampoline ( void * cookie ); void regulatorRoutine (); bool regulateServo ( QueueHandle_t responseQueue , size_t id , uint32_t timeSliceMs ); struct servo_info { servo_info () { current = 0xFFFF ; target = 0xFFFF ; speed_coef = 0.f ; speed_target = 0.f ; speed_raise = 0.f ; auto_stop = false ; auto_stop_counter = 0 ; } bool hasValidCurrent () const { return current != 0xFFFF ; } float speed_coef ; float speed_target ; float speed_raise ; uint16_t current ; uint16_t target ; bool auto_stop ; uint8_t auto_stop_counter ; }; std :: vector < servo_info > m_servos ; std :: mutex m_mutex ; }; };","title":"File RBCXSmartServo.h"},{"location":"api/RBCXStupidServo_8cpp/","text":"File RBCXStupidServo.cpp File List > build > RB3204-RBCX-library > src > RBCXStupidServo.cpp Go to the source code of this file. #include \"RBCXStupidServo.h\" #include \"RBCXManager.h\" Namespaces Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXStupidServo.cpp","title":"File RBCXStupidServo.cpp"},{"location":"api/RBCXStupidServo_8cpp/#file-rbcxstupidservocpp","text":"File List > build > RB3204-RBCX-library > src > RBCXStupidServo.cpp Go to the source code of this file. #include \"RBCXStupidServo.h\" #include \"RBCXManager.h\"","title":"File RBCXStupidServo.cpp"},{"location":"api/RBCXStupidServo_8cpp/#namespaces","text":"Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXStupidServo.cpp","title":"Namespaces"},{"location":"api/RBCXStupidServo_8cpp_source/","text":"File RBCXStupidServo.cpp File List > build > RB3204-RBCX-library > src > RBCXStupidServo.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \"RBCXStupidServo.h\" #include \"RBCXManager.h\" namespace rb { StupidServo :: StupidServo () : m_lastPosition ( NAN ) {} void StupidServo :: setPosition ( float posFraction ) { sendServoMsg ( posFraction ); } void StupidServo :: disable () { sendServoMsg ( NAN ); } void StupidServo :: sendServoMsg ( float position ) { std :: lock_guard < std :: mutex > l ( m_mutex ); if ( m_lastPosition == position ) return ; m_lastPosition = position ; const pb_size_t tag = std :: isnan ( position ) ? CoprocReq_SetStupidServo_disable_tag : CoprocReq_SetStupidServo_setPosition_tag ; Manager :: get (). sendToCoproc ( CoprocReq { . which_payload = CoprocReq_setStupidServo_tag , . payload = { . setStupidServo = { . servoIndex = m_id , . which_servoCmd = tag , . servoCmd = { . setPosition = position , }, }, }, }); } };","title":"File RBCXStupidServo.cpp"},{"location":"api/RBCXStupidServo_8cpp_source/#file-rbcxstupidservocpp","text":"File List > build > RB3204-RBCX-library > src > RBCXStupidServo.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \"RBCXStupidServo.h\" #include \"RBCXManager.h\" namespace rb { StupidServo :: StupidServo () : m_lastPosition ( NAN ) {} void StupidServo :: setPosition ( float posFraction ) { sendServoMsg ( posFraction ); } void StupidServo :: disable () { sendServoMsg ( NAN ); } void StupidServo :: sendServoMsg ( float position ) { std :: lock_guard < std :: mutex > l ( m_mutex ); if ( m_lastPosition == position ) return ; m_lastPosition = position ; const pb_size_t tag = std :: isnan ( position ) ? CoprocReq_SetStupidServo_disable_tag : CoprocReq_SetStupidServo_setPosition_tag ; Manager :: get (). sendToCoproc ( CoprocReq { . which_payload = CoprocReq_setStupidServo_tag , . payload = { . setStupidServo = { . servoIndex = m_id , . which_servoCmd = tag , . servoCmd = { . setPosition = position , }, }, }, }); } };","title":"File RBCXStupidServo.cpp"},{"location":"api/RBCXStupidServo_8h/","text":"File RBCXStupidServo.h File List > build > RB3204-RBCX-library > src > RBCXStupidServo.h Go to the source code of this file. #include <mutex> #include <stdint.h> #include \"rbcx.pb.h\" Namespaces Type Name namespace rb Classes Type Name class StupidServo The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXStupidServo.h","title":"File RBCXStupidServo.h"},{"location":"api/RBCXStupidServo_8h/#file-rbcxstupidservoh","text":"File List > build > RB3204-RBCX-library > src > RBCXStupidServo.h Go to the source code of this file. #include <mutex> #include <stdint.h> #include \"rbcx.pb.h\"","title":"File RBCXStupidServo.h"},{"location":"api/RBCXStupidServo_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXStupidServo_8h/#classes","text":"Type Name class StupidServo The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXStupidServo.h","title":"Classes"},{"location":"api/RBCXStupidServo_8h_source/","text":"File RBCXStupidServo.h File List > build > RB3204-RBCX-library > src > RBCXStupidServo.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #pragma once #include <mutex> #include <stdint.h> #include \"rbcx.pb.h\" namespace rb { class Manager ; class StupidServo { friend class Manager ; public : uint8_t id () const { return m_id ; } void setPosition ( float positionFraction ); float position () const { return m_lastPosition ; } void disable (); private : StupidServo (); ~ StupidServo () {} StupidServo ( const StupidServo & ) = delete ; void setId ( uint8_t id ) { m_id = id ; } void sendServoMsg ( float position ); std :: mutex m_mutex ; float m_lastPosition ; uint8_t m_id ; }; };","title":"File RBCXStupidServo.h"},{"location":"api/RBCXStupidServo_8h_source/#file-rbcxstupidservoh","text":"File List > build > RB3204-RBCX-library > src > RBCXStupidServo.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #pragma once #include <mutex> #include <stdint.h> #include \"rbcx.pb.h\" namespace rb { class Manager ; class StupidServo { friend class Manager ; public : uint8_t id () const { return m_id ; } void setPosition ( float positionFraction ); float position () const { return m_lastPosition ; } void disable (); private : StupidServo (); ~ StupidServo () {} StupidServo ( const StupidServo & ) = delete ; void setId ( uint8_t id ) { m_id = id ; } void sendServoMsg ( float position ); std :: mutex m_mutex ; float m_lastPosition ; uint8_t m_id ; }; };","title":"File RBCXStupidServo.h"},{"location":"api/RBCXTimers_8cpp/","text":"File RBCXTimers.cpp File List > build > RB3204-RBCX-library > src > RBCXTimers.cpp Go to the source code of this file. #include <freertos/FreeRTOS.h> #include <freertos/timers.h> #include \"RBCXManager.h\" #include \"RBCXTimers.h\" Namespaces Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXTimers.cpp","title":"File RBCXTimers.cpp"},{"location":"api/RBCXTimers_8cpp/#file-rbcxtimerscpp","text":"File List > build > RB3204-RBCX-library > src > RBCXTimers.cpp Go to the source code of this file. #include <freertos/FreeRTOS.h> #include <freertos/timers.h> #include \"RBCXManager.h\" #include \"RBCXTimers.h\"","title":"File RBCXTimers.cpp"},{"location":"api/RBCXTimers_8cpp/#namespaces","text":"Type Name namespace rb The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXTimers.cpp","title":"Namespaces"},{"location":"api/RBCXTimers_8cpp_source/","text":"File RBCXTimers.cpp File List > build > RB3204-RBCX-library > src > RBCXTimers.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 #include <freertos/FreeRTOS.h> #include <freertos/timers.h> #include \"RBCXManager.h\" #include \"RBCXTimers.h\" namespace rb { static void dieTimers ( TimerHandle_t timer ) { vPortFree ( timer ); vTaskDelete ( NULL ); // lol } void Timers::deleteFreeRtOsTimerTask () { xTimerStart ( xTimerCreate ( \"sike!\" , 1 , pdFALSE , NULL , dieTimers ), portMAX_DELAY ); } Timers & Timers::get () { static Timers instance ; return instance ; } Timers :: Timers () : m_id_counter ( 1 ) {} Timers ::~ Timers () {} void Timers :: timerCallback ( void * idVoid ) { auto & self = Timers :: get (); const auto id = ( uint16_t )( uintptr_t ) idVoid ; std :: lock_guard < std :: recursive_mutex > l ( self . m_mutex ); for ( const auto & tm : self . m_timers ) { if ( tm . id != id ) continue ; if ( ! tm . callback ()) { self . cancel ( id ); } break ; } } uint16_t Timers :: schedule ( uint32_t period_ms , std :: function < bool () > callback ) { std :: lock_guard < std :: recursive_mutex > l ( m_mutex ); const auto id = getFreeIdLocked (); const esp_timer_create_args_t timer_args = { . callback = timerCallback , . arg = ( void * )( uintptr_t ) id , . dispatch_method = ESP_TIMER_TASK , . name = \"rb_timer\" , }; esp_timer_handle_t timer = nullptr ; esp_timer_create ( & timer_args , & timer ); m_timers . emplace_back ( std :: move ( timer_t { . callback = callback , . handle = timer , . id = id , })); esp_timer_start_periodic ( timer , uint64_t ( period_ms ) * 1000 ); return id ; } bool Timers :: reset ( uint16_t id , uint32_t period_ms ) { std :: lock_guard < std :: recursive_mutex > l ( m_mutex ); for ( auto & t : m_timers ) { if ( t . id != id ) continue ; esp_timer_stop ( t . handle ); esp_timer_start_periodic ( t . handle , uint64_t ( period_ms ) * 1000 ); return true ; } return false ; } bool Timers :: cancel ( uint16_t id ) { std :: lock_guard < std :: recursive_mutex > l ( m_mutex ); const auto size = m_timers . size (); for ( size_t i = 0 ; i < size ; ++ i ) { if ( m_timers [ i ]. id == id ) { cancelByIdxLocked ( i ); return true ; } } return false ; } bool Timers :: stop ( uint16_t id ) { std :: lock_guard < std :: recursive_mutex > l ( m_mutex ); for ( auto & t : m_timers ) { if ( t . id != id ) continue ; esp_timer_stop ( t . handle ); return true ; } return false ; } void Timers :: cancelByIdxLocked ( size_t idx ) { auto & t = m_timers [ idx ]; esp_timer_stop ( t . handle ); esp_timer_delete ( t . handle ); const auto size = m_timers . size (); if ( idx + 1 < size ) { m_timers [ idx ]. swap ( m_timers [ size - 1 ]); } m_timers . pop_back (); } uint16_t Timers :: getFreeIdLocked () { uint16_t id = m_id_counter ; while ( 1 ) { if ( id == INVALID_ID ) { ++ id ; continue ; } bool found = false ; for ( const auto & t : m_timers ) { if ( t . id == id ) { found = true ; ++ id ; break ; } } if ( ! found ) { m_id_counter = id + 1 ; return id ; } } } bool Timers :: isOnTimerTask () const { return strcmp ( pcTaskGetTaskName ( NULL ), \"esp_timer\" ) == 0 ; } };","title":"File RBCXTimers.cpp"},{"location":"api/RBCXTimers_8cpp_source/#file-rbcxtimerscpp","text":"File List > build > RB3204-RBCX-library > src > RBCXTimers.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 #include <freertos/FreeRTOS.h> #include <freertos/timers.h> #include \"RBCXManager.h\" #include \"RBCXTimers.h\" namespace rb { static void dieTimers ( TimerHandle_t timer ) { vPortFree ( timer ); vTaskDelete ( NULL ); // lol } void Timers::deleteFreeRtOsTimerTask () { xTimerStart ( xTimerCreate ( \"sike!\" , 1 , pdFALSE , NULL , dieTimers ), portMAX_DELAY ); } Timers & Timers::get () { static Timers instance ; return instance ; } Timers :: Timers () : m_id_counter ( 1 ) {} Timers ::~ Timers () {} void Timers :: timerCallback ( void * idVoid ) { auto & self = Timers :: get (); const auto id = ( uint16_t )( uintptr_t ) idVoid ; std :: lock_guard < std :: recursive_mutex > l ( self . m_mutex ); for ( const auto & tm : self . m_timers ) { if ( tm . id != id ) continue ; if ( ! tm . callback ()) { self . cancel ( id ); } break ; } } uint16_t Timers :: schedule ( uint32_t period_ms , std :: function < bool () > callback ) { std :: lock_guard < std :: recursive_mutex > l ( m_mutex ); const auto id = getFreeIdLocked (); const esp_timer_create_args_t timer_args = { . callback = timerCallback , . arg = ( void * )( uintptr_t ) id , . dispatch_method = ESP_TIMER_TASK , . name = \"rb_timer\" , }; esp_timer_handle_t timer = nullptr ; esp_timer_create ( & timer_args , & timer ); m_timers . emplace_back ( std :: move ( timer_t { . callback = callback , . handle = timer , . id = id , })); esp_timer_start_periodic ( timer , uint64_t ( period_ms ) * 1000 ); return id ; } bool Timers :: reset ( uint16_t id , uint32_t period_ms ) { std :: lock_guard < std :: recursive_mutex > l ( m_mutex ); for ( auto & t : m_timers ) { if ( t . id != id ) continue ; esp_timer_stop ( t . handle ); esp_timer_start_periodic ( t . handle , uint64_t ( period_ms ) * 1000 ); return true ; } return false ; } bool Timers :: cancel ( uint16_t id ) { std :: lock_guard < std :: recursive_mutex > l ( m_mutex ); const auto size = m_timers . size (); for ( size_t i = 0 ; i < size ; ++ i ) { if ( m_timers [ i ]. id == id ) { cancelByIdxLocked ( i ); return true ; } } return false ; } bool Timers :: stop ( uint16_t id ) { std :: lock_guard < std :: recursive_mutex > l ( m_mutex ); for ( auto & t : m_timers ) { if ( t . id != id ) continue ; esp_timer_stop ( t . handle ); return true ; } return false ; } void Timers :: cancelByIdxLocked ( size_t idx ) { auto & t = m_timers [ idx ]; esp_timer_stop ( t . handle ); esp_timer_delete ( t . handle ); const auto size = m_timers . size (); if ( idx + 1 < size ) { m_timers [ idx ]. swap ( m_timers [ size - 1 ]); } m_timers . pop_back (); } uint16_t Timers :: getFreeIdLocked () { uint16_t id = m_id_counter ; while ( 1 ) { if ( id == INVALID_ID ) { ++ id ; continue ; } bool found = false ; for ( const auto & t : m_timers ) { if ( t . id == id ) { found = true ; ++ id ; break ; } } if ( ! found ) { m_id_counter = id + 1 ; return id ; } } } bool Timers :: isOnTimerTask () const { return strcmp ( pcTaskGetTaskName ( NULL ), \"esp_timer\" ) == 0 ; } };","title":"File RBCXTimers.cpp"},{"location":"api/RBCXTimers_8h/","text":"File RBCXTimers.h File List > build > RB3204-RBCX-library > src > RBCXTimers.h Go to the source code of this file. #include <esp_timer.h> #include <memory> #include <mutex> #include <vector> Namespaces Type Name namespace rb Classes Type Name class Timers The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXTimers.h","title":"File RBCXTimers.h"},{"location":"api/RBCXTimers_8h/#file-rbcxtimersh","text":"File List > build > RB3204-RBCX-library > src > RBCXTimers.h Go to the source code of this file. #include <esp_timer.h> #include <memory> #include <mutex> #include <vector>","title":"File RBCXTimers.h"},{"location":"api/RBCXTimers_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXTimers_8h/#classes","text":"Type Name class Timers The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXTimers.h","title":"Classes"},{"location":"api/RBCXTimers_8h_source/","text":"File RBCXTimers.h File List > build > RB3204-RBCX-library > src > RBCXTimers.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #pragma once #include <esp_timer.h> #include <memory> #include <mutex> #include <vector> namespace rb { class Manager ; class Timers ; class Timers { public : static constexpr uint16_t INVALID_ID = 0 ; static void deleteFreeRtOsTimerTask (); static Timers & get (); uint16_t schedule ( uint32_t period_ms , std :: function < bool () > callback ); bool reset ( uint16_t id , uint32_t period_ms ); bool cancel ( uint16_t id ); bool stop ( uint16_t id ); // returns true if the calling code is running in the timer task. bool isOnTimerTask () const ; private : struct timer_t { std :: function < bool () > callback ; esp_timer_handle_t handle ; uint16_t id ; void swap ( timer_t & o ) { callback . swap ( o . callback ); std :: swap ( handle , o . handle ); std :: swap ( id , o . id ); } }; static void timerCallback ( void * handleVoid ); Timers (); ~ Timers (); void cancelByIdxLocked ( size_t idx ); uint16_t getFreeIdLocked (); std :: vector < timer_t > m_timers ; std :: recursive_mutex m_mutex ; uint16_t m_id_counter ; }; };","title":"File RBCXTimers.h"},{"location":"api/RBCXTimers_8h_source/#file-rbcxtimersh","text":"File List > build > RB3204-RBCX-library > src > RBCXTimers.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #pragma once #include <esp_timer.h> #include <memory> #include <mutex> #include <vector> namespace rb { class Manager ; class Timers ; class Timers { public : static constexpr uint16_t INVALID_ID = 0 ; static void deleteFreeRtOsTimerTask (); static Timers & get (); uint16_t schedule ( uint32_t period_ms , std :: function < bool () > callback ); bool reset ( uint16_t id , uint32_t period_ms ); bool cancel ( uint16_t id ); bool stop ( uint16_t id ); // returns true if the calling code is running in the timer task. bool isOnTimerTask () const ; private : struct timer_t { std :: function < bool () > callback ; esp_timer_handle_t handle ; uint16_t id ; void swap ( timer_t & o ) { callback . swap ( o . callback ); std :: swap ( handle , o . handle ); std :: swap ( id , o . id ); } }; static void timerCallback ( void * handleVoid ); Timers (); ~ Timers (); void cancelByIdxLocked ( size_t idx ); uint16_t getFreeIdLocked (); std :: vector < timer_t > m_timers ; std :: recursive_mutex m_mutex ; uint16_t m_id_counter ; }; };","title":"File RBCXTimers.h"},{"location":"api/RBCXUltrasound_8cpp/","text":"File RBCXUltrasound.cpp File List > build > RB3204-RBCX-library > src > RBCXUltrasound.cpp Go to the source code of this file. #include <esp_log.h> #include \"RBCXManager.h\" #include \"RBCXUltrasound.h\" #include \"rbcx.pb.h\" Namespaces Type Name namespace rb Macros Type Name define TAG \"RBCXUltrasound\" Macro Definition Documentation define TAG 1 #define TAG \"RBCXUltrasound\" The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXUltrasound.cpp","title":"File RBCXUltrasound.cpp"},{"location":"api/RBCXUltrasound_8cpp/#file-rbcxultrasoundcpp","text":"File List > build > RB3204-RBCX-library > src > RBCXUltrasound.cpp Go to the source code of this file. #include <esp_log.h> #include \"RBCXManager.h\" #include \"RBCXUltrasound.h\" #include \"rbcx.pb.h\"","title":"File RBCXUltrasound.cpp"},{"location":"api/RBCXUltrasound_8cpp/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXUltrasound_8cpp/#macros","text":"Type Name define TAG \"RBCXUltrasound\"","title":"Macros"},{"location":"api/RBCXUltrasound_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"api/RBCXUltrasound_8cpp/#define-tag","text":"1 #define TAG \"RBCXUltrasound\" The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXUltrasound.cpp","title":"define TAG"},{"location":"api/RBCXUltrasound_8cpp_source/","text":"File RBCXUltrasound.cpp File List > build > RB3204-RBCX-library > src > RBCXUltrasound.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 #include <esp_log.h> #include \"RBCXManager.h\" #include \"RBCXUltrasound.h\" #include \"rbcx.pb.h\" #define TAG \"RBCXUltrasound\" namespace rb { Ultrasound :: Ultrasound () : m_index ( 0 ) , m_lastUs ( 0 ) , m_lastDistanceMm ( 0 ) , m_speedOfSound ( defaultSpeedOfSound / 100.f ) , m_measuring ( false ) , m_timeoutTimer ( 0 ) {} Ultrasound ::~ Ultrasound () {} void Ultrasound :: init ( uint8_t index ) { m_index = index ; m_timeoutTimer = Timers :: get (). schedule ( 0xFFFFFFFF , [ this ]() -> bool { ESP_LOGE ( TAG , \"Ultrasound %d response timeout! \\n \" , m_index ); onMeasuringDone ( CoprocStat_UltrasoundStat { 0 }); return true ; // return true to prevent cancel, was stopped in onMeasuringDone }); Timers :: get (). stop ( m_timeoutTimer ); } void Ultrasound :: setSpeedOfSound ( float speedOfSoundInMetersPerSecond ) { m_mutex . lock (); m_speedOfSound = speedOfSoundInMetersPerSecond / 100.f ; recalculateLastDistanceLocked (); m_mutex . unlock (); } void Ultrasound :: measureAsync ( callback_t callback ) { std :: lock_guard < std :: recursive_mutex > ul ( m_mutex ); if ( ! m_measuring ) { m_measuring = true ; Manager :: get (). sendToCoproc ( CoprocReq { . which_payload = CoprocReq_ultrasoundReq_tag , . payload = { . ultrasoundReq = { . utsIndex = m_index , . which_utsCmd = CoprocReq_UltrasoundReq_singlePing_tag , }, }, }); Timers :: get (). reset ( m_timeoutTimer , 250 ); } if ( callback ) m_callbacks . emplace_back ( std :: move ( callback )); } uint32_t Ultrasound :: measure () { if ( Timers :: get (). isOnTimerTask ()) { ESP_LOGE ( TAG , \"you can't call measure() from the ESP timer task, as it is a \" \"blocking function. Use measureAsync. \\n \" ); abort (); } std :: unique_lock < std :: recursive_mutex > ul ( m_mutex ); measureAsync (); m_measuringDone . wait ( ul ); return m_lastDistanceMm ; } void Ultrasound :: onMeasuringDone ( const CoprocStat_UltrasoundStat & result ) { uint32_t distance ; { std :: lock_guard < std :: recursive_mutex > ul ( m_mutex ); m_lastUs = result . roundtripMicrosecs ; recalculateLastDistanceLocked (); distance = m_lastDistanceMm ; m_measuring = false ; Timers :: get (). stop ( m_timeoutTimer ); m_measuringDone . notify_all (); for ( auto itr = m_callbacks . begin (); itr != m_callbacks . end ();) { if ( ! ( * itr )( distance )) { itr = m_callbacks . erase ( itr ); } else { ++ itr ; } } if ( ! m_callbacks . empty ()) { measureAsync (); } } } void Ultrasound :: recalculateLastDistanceLocked () { if ( m_lastUs == 0 ) { m_lastDistanceMm = 0 ; return ; } m_lastDistanceMm = uint32_t ( m_speedOfSound * ( float ( m_lastUs ) / 10.f )) / 2 ; } };","title":"File RBCXUltrasound.cpp"},{"location":"api/RBCXUltrasound_8cpp_source/#file-rbcxultrasoundcpp","text":"File List > build > RB3204-RBCX-library > src > RBCXUltrasound.cpp Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 #include <esp_log.h> #include \"RBCXManager.h\" #include \"RBCXUltrasound.h\" #include \"rbcx.pb.h\" #define TAG \"RBCXUltrasound\" namespace rb { Ultrasound :: Ultrasound () : m_index ( 0 ) , m_lastUs ( 0 ) , m_lastDistanceMm ( 0 ) , m_speedOfSound ( defaultSpeedOfSound / 100.f ) , m_measuring ( false ) , m_timeoutTimer ( 0 ) {} Ultrasound ::~ Ultrasound () {} void Ultrasound :: init ( uint8_t index ) { m_index = index ; m_timeoutTimer = Timers :: get (). schedule ( 0xFFFFFFFF , [ this ]() -> bool { ESP_LOGE ( TAG , \"Ultrasound %d response timeout! \\n \" , m_index ); onMeasuringDone ( CoprocStat_UltrasoundStat { 0 }); return true ; // return true to prevent cancel, was stopped in onMeasuringDone }); Timers :: get (). stop ( m_timeoutTimer ); } void Ultrasound :: setSpeedOfSound ( float speedOfSoundInMetersPerSecond ) { m_mutex . lock (); m_speedOfSound = speedOfSoundInMetersPerSecond / 100.f ; recalculateLastDistanceLocked (); m_mutex . unlock (); } void Ultrasound :: measureAsync ( callback_t callback ) { std :: lock_guard < std :: recursive_mutex > ul ( m_mutex ); if ( ! m_measuring ) { m_measuring = true ; Manager :: get (). sendToCoproc ( CoprocReq { . which_payload = CoprocReq_ultrasoundReq_tag , . payload = { . ultrasoundReq = { . utsIndex = m_index , . which_utsCmd = CoprocReq_UltrasoundReq_singlePing_tag , }, }, }); Timers :: get (). reset ( m_timeoutTimer , 250 ); } if ( callback ) m_callbacks . emplace_back ( std :: move ( callback )); } uint32_t Ultrasound :: measure () { if ( Timers :: get (). isOnTimerTask ()) { ESP_LOGE ( TAG , \"you can't call measure() from the ESP timer task, as it is a \" \"blocking function. Use measureAsync. \\n \" ); abort (); } std :: unique_lock < std :: recursive_mutex > ul ( m_mutex ); measureAsync (); m_measuringDone . wait ( ul ); return m_lastDistanceMm ; } void Ultrasound :: onMeasuringDone ( const CoprocStat_UltrasoundStat & result ) { uint32_t distance ; { std :: lock_guard < std :: recursive_mutex > ul ( m_mutex ); m_lastUs = result . roundtripMicrosecs ; recalculateLastDistanceLocked (); distance = m_lastDistanceMm ; m_measuring = false ; Timers :: get (). stop ( m_timeoutTimer ); m_measuringDone . notify_all (); for ( auto itr = m_callbacks . begin (); itr != m_callbacks . end ();) { if ( ! ( * itr )( distance )) { itr = m_callbacks . erase ( itr ); } else { ++ itr ; } } if ( ! m_callbacks . empty ()) { measureAsync (); } } } void Ultrasound :: recalculateLastDistanceLocked () { if ( m_lastUs == 0 ) { m_lastDistanceMm = 0 ; return ; } m_lastDistanceMm = uint32_t ( m_speedOfSound * ( float ( m_lastUs ) / 10.f )) / 2 ; } };","title":"File RBCXUltrasound.cpp"},{"location":"api/RBCXUltrasound_8h/","text":"File RBCXUltrasound.h File List > build > RB3204-RBCX-library > src > RBCXUltrasound.h Go to the source code of this file. #include <condition_variable> #include <functional> #include <mutex> #include <stdint.h> #include <vector> #include \"RBCXTimers.h\" #include \"rbcx.pb.h\" Namespaces Type Name namespace rb Classes Type Name class Ultrasound The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXUltrasound.h","title":"File RBCXUltrasound.h"},{"location":"api/RBCXUltrasound_8h/#file-rbcxultrasoundh","text":"File List > build > RB3204-RBCX-library > src > RBCXUltrasound.h Go to the source code of this file. #include <condition_variable> #include <functional> #include <mutex> #include <stdint.h> #include <vector> #include \"RBCXTimers.h\" #include \"rbcx.pb.h\"","title":"File RBCXUltrasound.h"},{"location":"api/RBCXUltrasound_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXUltrasound_8h/#classes","text":"Type Name class Ultrasound The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXUltrasound.h","title":"Classes"},{"location":"api/RBCXUltrasound_8h_source/","text":"File RBCXUltrasound.h File List > build > RB3204-RBCX-library > src > RBCXUltrasound.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #pragma once #include <condition_variable> #include <functional> #include <mutex> #include <stdint.h> #include <vector> #include \"RBCXTimers.h\" #include \"rbcx.pb.h\" namespace rb { class Manager ; class Ultrasound { friend class Manager ; public : static constexpr float defaultSpeedOfSound = 347.13f ; typedef std :: function < bool ( uint32_t ) > callback_t ; uint32_t lastDistanceMm () const { return m_lastDistanceMm ; } uint32_t lastDurationUs () const { return m_lastUs ; } bool isLastMeasurementValid () const { return m_lastUs != 0 ; } void setSpeedOfSound ( float speedOfSoundInMetersPerSecond = defaultSpeedOfSound ); float getSpeedOfSound () const { return m_speedOfSound ; } void measureAsync ( callback_t callback = nullptr ); uint32_t measure (); private : Ultrasound (); Ultrasound ( const Ultrasound & ) = delete ; ~ Ultrasound (); void init ( uint8_t index ); void recalculateLastDistanceLocked (); void onMeasuringDone ( const CoprocStat_UltrasoundStat & result ); uint8_t m_index ; uint32_t m_lastUs ; uint32_t m_lastDistanceMm ; float m_speedOfSound ; bool m_measuring ; std :: vector < callback_t > m_callbacks ; std :: recursive_mutex m_mutex ; std :: condition_variable_any m_measuringDone ; uint16_t m_timeoutTimer ; }; };","title":"File RBCXUltrasound.h"},{"location":"api/RBCXUltrasound_8h_source/#file-rbcxultrasoundh","text":"File List > build > RB3204-RBCX-library > src > RBCXUltrasound.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #pragma once #include <condition_variable> #include <functional> #include <mutex> #include <stdint.h> #include <vector> #include \"RBCXTimers.h\" #include \"rbcx.pb.h\" namespace rb { class Manager ; class Ultrasound { friend class Manager ; public : static constexpr float defaultSpeedOfSound = 347.13f ; typedef std :: function < bool ( uint32_t ) > callback_t ; uint32_t lastDistanceMm () const { return m_lastDistanceMm ; } uint32_t lastDurationUs () const { return m_lastUs ; } bool isLastMeasurementValid () const { return m_lastUs != 0 ; } void setSpeedOfSound ( float speedOfSoundInMetersPerSecond = defaultSpeedOfSound ); float getSpeedOfSound () const { return m_speedOfSound ; } void measureAsync ( callback_t callback = nullptr ); uint32_t measure (); private : Ultrasound (); Ultrasound ( const Ultrasound & ) = delete ; ~ Ultrasound (); void init ( uint8_t index ); void recalculateLastDistanceLocked (); void onMeasuringDone ( const CoprocStat_UltrasoundStat & result ); uint8_t m_index ; uint32_t m_lastUs ; uint32_t m_lastDistanceMm ; float m_speedOfSound ; bool m_measuring ; std :: vector < callback_t > m_callbacks ; std :: recursive_mutex m_mutex ; std :: condition_variable_any m_measuringDone ; uint16_t m_timeoutTimer ; }; };","title":"File RBCXUltrasound.h"},{"location":"api/RBCXUtil_8h/","text":"File RBCXUtil.h File List > build > RB3204-RBCX-library > src > RBCXUtil.h Go to the source code of this file. #include <chrono> #include <freertos/FreeRTOS.h> #include <freertos/task.h> #include <ratio> Namespaces Type Name namespace rb Macros Type Name define RBCX_ENUM_IMPL_MASK_OPERATORS (T) Macro Definition Documentation define RBCX_ENUM_IMPL_MASK_OPERATORS 1 2 3 #define RBCX_ENUM_IMPL_MASK_OPERATORS ( T ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXUtil.h","title":"File RBCXUtil.h"},{"location":"api/RBCXUtil_8h/#file-rbcxutilh","text":"File List > build > RB3204-RBCX-library > src > RBCXUtil.h Go to the source code of this file. #include <chrono> #include <freertos/FreeRTOS.h> #include <freertos/task.h> #include <ratio>","title":"File RBCXUtil.h"},{"location":"api/RBCXUtil_8h/#namespaces","text":"Type Name namespace rb","title":"Namespaces"},{"location":"api/RBCXUtil_8h/#macros","text":"Type Name define RBCX_ENUM_IMPL_MASK_OPERATORS (T)","title":"Macros"},{"location":"api/RBCXUtil_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"api/RBCXUtil_8h/#define-rbcx_enum_impl_mask_operators","text":"1 2 3 #define RBCX_ENUM_IMPL_MASK_OPERATORS ( T ) The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXUtil.h","title":"define RBCX_ENUM_IMPL_MASK_OPERATORS"},{"location":"api/RBCXUtil_8h_source/","text":"File RBCXUtil.h File List > build > RB3204-RBCX-library > src > RBCXUtil.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #pragma once #include <chrono> #include <freertos/FreeRTOS.h> #include <freertos/task.h> #include <ratio> namespace rb { template < typename T > T clamp ( T value , T min , T max ) { if ( value < min ) { return min ; } else if ( value > max ) { return max ; } return value ; } inline void delayMs ( int ms ) { vTaskDelay ( ms / portTICK_PERIOD_MS ); } inline void delay ( std :: chrono :: duration < uint32_t , std :: milli > delay ) { vTaskDelay ( delay . count () / portTICK_PERIOD_MS ); } #define RBCX_ENUM_IMPL_MASK_OPERATORS(T) \\ inline T operator|(T a, T b) { \\ return static_cast<T>(static_cast<int>(a) | static_cast<int>(b)); \\ } \\ \\ inline T operator&(T a, T b) { \\ return static_cast<T>(static_cast<int>(a) & static_cast<int>(b)); \\ } \\ \\ inline T operator^(T a, T b) { \\ return static_cast<T>(static_cast<int>(a) ^ static_cast<int>(b)); \\ } \\ \\ inline T operator|=(T& a, T b) { \\ return static_cast<T>( \\ reinterpret_cast<int&>(a) |= static_cast<int>(b)); \\ } \\ \\ inline T operator&=(T& a, T b) { \\ return static_cast<T>( \\ reinterpret_cast<int&>(a) &= static_cast<int>(b)); \\ } \\ \\ inline T operator^=(T& a, T b) { \\ return static_cast<T>( \\ reinterpret_cast<int&>(a) ^= static_cast<int>(b)); \\ } \\ \\ inline T operator~(T a) { return static_cast<T>(~static_cast<int>(a)); } \\ \\ inline T operator<<=(T& a, int b) { \\ return static_cast<T>( \\ reinterpret_cast<int&>(a) <<= static_cast<int>(b)); \\ } \\ \\ inline T operator>>=(T& a, int b) { \\ return static_cast<T>( \\ reinterpret_cast<int&>(a) >>= static_cast<int>(b)); \\ } \\ \\ inline T operator<<(T a, int b) { \\ return static_cast<T>(static_cast<int>(a) << static_cast<int>(b)); \\ } \\ \\ inline T operator>>(T a, int b) { \\ return static_cast<T>(static_cast<int>(a) >> static_cast<int>(b)); \\ } \\ \\ T operator+=(T& a, T b) = delete; \\ T operator-=(T& a, T b) = delete; \\ T operator++(T a) = delete; \\ T operator--(T a) = delete; } // namespace rb","title":"File RBCXUtil.h"},{"location":"api/RBCXUtil_8h_source/#file-rbcxutilh","text":"File List > build > RB3204-RBCX-library > src > RBCXUtil.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #pragma once #include <chrono> #include <freertos/FreeRTOS.h> #include <freertos/task.h> #include <ratio> namespace rb { template < typename T > T clamp ( T value , T min , T max ) { if ( value < min ) { return min ; } else if ( value > max ) { return max ; } return value ; } inline void delayMs ( int ms ) { vTaskDelay ( ms / portTICK_PERIOD_MS ); } inline void delay ( std :: chrono :: duration < uint32_t , std :: milli > delay ) { vTaskDelay ( delay . count () / portTICK_PERIOD_MS ); } #define RBCX_ENUM_IMPL_MASK_OPERATORS(T) \\ inline T operator|(T a, T b) { \\ return static_cast<T>(static_cast<int>(a) | static_cast<int>(b)); \\ } \\ \\ inline T operator&(T a, T b) { \\ return static_cast<T>(static_cast<int>(a) & static_cast<int>(b)); \\ } \\ \\ inline T operator^(T a, T b) { \\ return static_cast<T>(static_cast<int>(a) ^ static_cast<int>(b)); \\ } \\ \\ inline T operator|=(T& a, T b) { \\ return static_cast<T>( \\ reinterpret_cast<int&>(a) |= static_cast<int>(b)); \\ } \\ \\ inline T operator&=(T& a, T b) { \\ return static_cast<T>( \\ reinterpret_cast<int&>(a) &= static_cast<int>(b)); \\ } \\ \\ inline T operator^=(T& a, T b) { \\ return static_cast<T>( \\ reinterpret_cast<int&>(a) ^= static_cast<int>(b)); \\ } \\ \\ inline T operator~(T a) { return static_cast<T>(~static_cast<int>(a)); } \\ \\ inline T operator<<=(T& a, int b) { \\ return static_cast<T>( \\ reinterpret_cast<int&>(a) <<= static_cast<int>(b)); \\ } \\ \\ inline T operator>>=(T& a, int b) { \\ return static_cast<T>( \\ reinterpret_cast<int&>(a) >>= static_cast<int>(b)); \\ } \\ \\ inline T operator<<(T a, int b) { \\ return static_cast<T>(static_cast<int>(a) << static_cast<int>(b)); \\ } \\ \\ inline T operator>>(T a, int b) { \\ return static_cast<T>(static_cast<int>(a) >> static_cast<int>(b)); \\ } \\ \\ T operator+=(T& a, T b) = delete; \\ T operator-=(T& a, T b) = delete; \\ T operator++(T a) = delete; \\ T operator--(T a) = delete; } // namespace rb","title":"File RBCXUtil.h"},{"location":"api/RBCXVersion_8h/","text":"File RBCXVersion.h File List > build > RB3204-RBCX-library > src > RBCXVersion.h Go to the source code of this file. Macros Type Name define RB3204 define RB3204_MAJOR 0 define RB3204_MINOR 0 define RB3204_PATCH 2 define RB3204_RBCX define RBCX Macro Definition Documentation define RB3204 1 #define RB3204 define RB3204_MAJOR 1 #define RB3204_MAJOR 0 define RB3204_MINOR 1 #define RB3204_MINOR 0 define RB3204_PATCH 1 #define RB3204_PATCH 2 define RB3204_RBCX 1 #define RB3204_RBCX define RBCX 1 #define RBCX The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXVersion.h","title":"File RBCXVersion.h"},{"location":"api/RBCXVersion_8h/#file-rbcxversionh","text":"File List > build > RB3204-RBCX-library > src > RBCXVersion.h Go to the source code of this file.","title":"File RBCXVersion.h"},{"location":"api/RBCXVersion_8h/#macros","text":"Type Name define RB3204 define RB3204_MAJOR 0 define RB3204_MINOR 0 define RB3204_PATCH 2 define RB3204_RBCX define RBCX","title":"Macros"},{"location":"api/RBCXVersion_8h/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"api/RBCXVersion_8h/#define-rb3204","text":"1 #define RB3204","title":"define RB3204"},{"location":"api/RBCXVersion_8h/#define-rb3204_major","text":"1 #define RB3204_MAJOR 0","title":"define RB3204_MAJOR"},{"location":"api/RBCXVersion_8h/#define-rb3204_minor","text":"1 #define RB3204_MINOR 0","title":"define RB3204_MINOR"},{"location":"api/RBCXVersion_8h/#define-rb3204_patch","text":"1 #define RB3204_PATCH 2","title":"define RB3204_PATCH"},{"location":"api/RBCXVersion_8h/#define-rb3204_rbcx","text":"1 #define RB3204_RBCX","title":"define RB3204_RBCX"},{"location":"api/RBCXVersion_8h/#define-rbcx","text":"1 #define RBCX The documentation for this class was generated from the following file build/RB3204-RBCX-library/src/RBCXVersion.h","title":"define RBCX"},{"location":"api/RBCXVersion_8h_source/","text":"File RBCXVersion.h File List > build > RB3204-RBCX-library > src > RBCXVersion.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 #pragma once #define RB3204 #define RB3204_RBCX #define RBCX #define RB3204_MAJOR 0 #define RB3204_MINOR 0 #define RB3204_PATCH 2","title":"File RBCXVersion.h"},{"location":"api/RBCXVersion_8h_source/#file-rbcxversionh","text":"File List > build > RB3204-RBCX-library > src > RBCXVersion.h Go to the documentation of this file. 1 2 3 4 5 6 7 8 9 #pragma once #define RB3204 #define RB3204_RBCX #define RBCX #define RB3204_MAJOR 0 #define RB3204_MINOR 0 #define RB3204_PATCH 2","title":"File RBCXVersion.h"},{"location":"api/namespaces/","text":"Namespace List Here is a list of all namespaces with brief descriptions: namespace rb","title":"Namespace List"},{"location":"api/namespaces/#namespace-list","text":"Here is a list of all namespaces with brief descriptions: namespace rb","title":"Namespace List"},{"location":"api/classes/","text":"Class Index a Angle ( rb ) b Battery ( rb ) Buttons ( rb ) l Leds ( rb ) m Manager ( rb ) Motor ( rb ) MotorChangeBuilder ( rb ) n Nvs ( rb ) p Piezo ( rb ) s SmartServoBus ( rb ) StupidServo ( rb ) servo_info t Timers ( rb ) timer_t u Ultrasound ( rb )","title":"Class Index"},{"location":"api/classes/#class-index","text":"","title":"Class Index"},{"location":"api/classes/#a","text":"Angle ( rb )","title":"a"},{"location":"api/classes/#b","text":"Battery ( rb ) Buttons ( rb )","title":"b"},{"location":"api/classes/#l","text":"Leds ( rb )","title":"l"},{"location":"api/classes/#m","text":"Manager ( rb ) Motor ( rb ) MotorChangeBuilder ( rb )","title":"m"},{"location":"api/classes/#n","text":"Nvs ( rb )","title":"n"},{"location":"api/classes/#p","text":"Piezo ( rb )","title":"p"},{"location":"api/classes/#s","text":"SmartServoBus ( rb ) StupidServo ( rb ) servo_info","title":"s"},{"location":"api/classes/#t","text":"Timers ( rb ) timer_t","title":"t"},{"location":"api/classes/#u","text":"Ultrasound ( rb )","title":"u"},{"location":"api/hierarchy/","text":"Class Hierarchy This inheritance list is sorted roughly, but not completely, alphabetically: class rb::Angle class rb::Battery Contains the battery state and can control the robot's power. class rb::Buttons class rb::Leds class rb::Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. class rb::Motor class rb::MotorChangeBuilder Helper class for building the motor change event. class rb::Nvs class rb::Piezo Helper class for controlling the piezo. class rb::SmartServoBus class rb::StupidServo class rb::Timers class rb::Ultrasound struct rb::SmartServoBus::servo_info struct rb::Timers::timer_t","title":"Class Hierarchy"},{"location":"api/hierarchy/#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: class rb::Angle class rb::Battery Contains the battery state and can control the robot's power. class rb::Buttons class rb::Leds class rb::Manager The main library class for working with the RBCX board. Call the install() method at the start of your program. class rb::Motor class rb::MotorChangeBuilder Helper class for building the motor change event. class rb::Nvs class rb::Piezo Helper class for controlling the piezo. class rb::SmartServoBus class rb::StupidServo class rb::Timers class rb::Ultrasound struct rb::SmartServoBus::servo_info struct rb::Timers::timer_t","title":"Class Hierarchy"},{"location":"api/modules/","text":"Modules Here is a list of all modules:","title":"Modules"},{"location":"api/modules/#modules","text":"Here is a list of all modules:","title":"Modules"},{"location":"api/pages/","text":"Class List Here are the classes, structs, unions and interfaces with brief descriptions:","title":"Class List"},{"location":"api/pages/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions:","title":"Class List"},{"location":"api/class_members/","text":"Class Members a Angle ( rb::Angle ) auto_stop ( rb::SmartServoBus::servo_info ) auto_stop_counter ( rb::SmartServoBus::servo_info ) b BATTERY_IN_THRESHOLD ( rb::Battery ) Battery ( rb::Battery ) Buttons ( rb::Buttons ) byId ( rb::Buttons , rb::Leds ) blue ( rb::Leds ) buttons ( rb::Manager ) brake ( rb::Motor , rb::MotorChangeBuilder ) c Count ( rb::Buttons ) callback_t ( rb::Buttons , rb::Motor , rb::Ultrasound ) consumerRoutine ( rb::Manager ) consumerRoutineTrampoline ( rb::Manager ) coprocFwVersion ( rb::Manager ) coprocFwVersionAssert ( rb::Manager ) commit ( rb::Nvs ) cancel ( rb::Timers ) cancelByIdxLocked ( rb::Timers ) current ( rb::SmartServoBus::servo_info ) callback ( rb::Timers::timer_t ) d deg ( rb::Angle ) down ( rb::Buttons ) drive ( rb::Motor , rb::MotorChangeBuilder ) driveToValue ( rb::Motor , rb::MotorChangeBuilder ) disable ( rb::StupidServo ) deleteFreeRtOsTimerTask ( rb::Timers ) defaultSpeedOfSound ( rb::Ultrasound ) e existsInt ( rb::Nvs ) existsString ( rb::Nvs ) g green ( rb::Leds ) get ( rb::Manager , rb::Timers ) getInt ( rb::Nvs ) getString ( rb::Nvs ) getId ( rb::SmartServoBus ) getFreeIdLocked ( rb::Timers ) getSpeedOfSound ( rb::Ultrasound ) h hasValidCurrent ( rb::SmartServoBus::servo_info ) handle ( rb::Timers::timer_t ) i isNaN ( rb::Angle ) isPoweredByBattery ( rb::Battery ) install ( rb::Manager , rb::SmartServoBus ) id ( rb::Motor , rb::Timers::timer_t ) initFlash ( rb::Nvs ) INVALID_ID ( rb::Timers ) isOnTimerTask ( rb::Timers ) init ( rb::Ultrasound ) isLastMeasurementValid ( rb::Ultrasound ) k keepaliveRoutine ( rb::Manager ) l left ( rb::Buttons ) Leds ( rb::Leds ) limit ( rb::SmartServoBus ) lastDistanceMm ( rb::Ultrasound ) lastDurationUs ( rb::Ultrasound ) m m_state ( rb::Battery ) m_buttonsSet ( rb::Buttons ) m_callbacks ( rb::Buttons , rb::Ultrasound ) m_mutex ( rb::Buttons , rb::Leds , rb::Motor , rb::SmartServoBus , rb::StupidServo , rb::Timers , rb::Ultrasound ) m_ledsOn ( rb::Leds ) Manager ( rb::Manager ) m_battery ( rb::Manager ) m_buttons ( rb::Manager ) m_codec ( rb::Manager ) m_codecTxMutex ( rb::Manager ) m_coprocFwVersion ( rb::Manager ) m_coprocSemaphore ( rb::Manager ) m_coprocWatchdogTimer ( rb::Manager ) m_keepaliveTask ( rb::Manager ) m_leds ( rb::Manager ) m_motors ( rb::Manager ) m_motors_last_set ( rb::Manager ) m_piezo ( rb::Manager ) m_stupidServos ( rb::Manager ) m_txBuf ( rb::Manager ) m_ultrasounds ( rb::Manager ) monitorTask ( rb::Manager ) motor ( rb::Manager ) motorsFailSafe ( rb::Manager ) Motor ( rb::Motor ) m_id ( rb::Motor , rb::StupidServo ) m_infoCbs ( rb::Motor ) m_lastReq ( rb::Motor ) m_mode ( rb::Motor ) m_position ( rb::Motor ) m_positionCb ( rb::Motor ) m_power ( rb::Motor ) m_pwm_max_percent ( rb::Motor ) m_speed ( rb::Motor ) MotorChangeBuilder ( rb::MotorChangeBuilder ) m_calls ( rb::MotorChangeBuilder ) m_dirty ( rb::Nvs ) m_handle ( rb::Nvs ) m_on ( rb::Piezo ) m_servos ( rb::SmartServoBus ) m_lastPosition ( rb::StupidServo ) m_id_counter ( rb::Timers ) m_timers ( rb::Timers ) m_index ( rb::Ultrasound ) m_lastDistanceMm ( rb::Ultrasound ) m_lastUs ( rb::Ultrasound ) m_measuring ( rb::Ultrasound ) m_measuringDone ( rb::Ultrasound ) m_speedOfSound ( rb::Ultrasound ) m_timeoutTimer ( rb::Ultrasound ) measure ( rb::Ultrasound ) measureAsync ( rb::Ultrasound ) n nan ( rb::Angle ) Nvs ( rb::Nvs ) o operator*= ( rb::Angle ) operator+= ( rb::Angle ) operator- ( rb::Angle ) operator-= ( rb::Angle ) operator/= ( rb::Angle ) off ( rb::Buttons ) on ( rb::Buttons ) onChange ( rb::Buttons ) operator= ( rb::Manager ) onMotorStat ( rb::Motor ) onMeasuringDone ( rb::Ultrasound ) p Pi ( rb::Angle ) pct ( rb::Battery ) position ( rb::Motor , rb::StupidServo ) power ( rb::Motor , rb::MotorChangeBuilder ) pwmMaxPercent ( rb::Motor , rb::MotorChangeBuilder ) Piezo ( rb::Piezo ) pos ( rb::SmartServoBus ) posOffline ( rb::SmartServoBus ) r rad ( rb::Angle ) right ( rb::Buttons ) red ( rb::Leds ) resetMotorsFailSafe ( rb::Manager ) requestInfo ( rb::Motor ) regulateServo ( rb::SmartServoBus ) regulatorRoutine ( rb::SmartServoBus ) regulatorRoutineTrampoline ( rb::SmartServoBus ) reset ( rb::Timers ) recalculateLastDistanceLocked ( rb::Ultrasound ) s setState ( rb::Battery , rb::Buttons , rb::Piezo ) shutdown ( rb::Battery ) schedule ( rb::Manager , rb::Timers ) sendToCoproc ( rb::Manager ) setMotors ( rb::Manager ) stupidServo ( rb::Manager ) scale ( rb::Motor ) sendMotorReq ( rb::Motor ) sendPositionReq ( rb::Motor ) setConfig ( rb::Motor ) setCurrentPosition ( rb::Motor ) setId ( rb::Motor , rb::SmartServoBus , rb::StupidServo ) speed ( rb::Motor , rb::MotorChangeBuilder ) set ( rb::MotorChangeBuilder , rb::SmartServoBus ) start ( rb::Piezo ) stop ( rb::Piezo , rb::Timers ) SmartServoBus ( rb::SmartServoBus ) setAutoStop ( rb::SmartServoBus ) StupidServo ( rb::StupidServo ) sendServoMsg ( rb::StupidServo ) setPosition ( rb::StupidServo ) setSpeedOfSound ( rb::Ultrasound ) servo_info ( rb::SmartServoBus::servo_info ) speed_coef ( rb::SmartServoBus::servo_info ) speed_raise ( rb::SmartServoBus::servo_info ) speed_target ( rb::SmartServoBus::servo_info ) swap ( rb::Timers::timer_t ) t temperatureC ( rb::Battery ) timers ( rb::Manager ) Timers ( rb::Timers ) timerCallback ( rb::Timers ) target ( rb::SmartServoBus::servo_info ) u up ( rb::Buttons ) ultrasound ( rb::Manager ) Ultrasound ( rb::Ultrasound ) v VOLTAGE_MAX ( rb::Battery ) VOLTAGE_MIN ( rb::Battery ) w writeInt ( rb::Nvs ) writeString ( rb::Nvs ) y yellow ( rb::Leds ) ~ ~Battery ( rb::Battery ) ~Buttons ( rb::Buttons ) ~Leds ( rb::Leds ) ~Manager ( rb::Manager ) ~MotorChangeBuilder ( rb::MotorChangeBuilder ) ~Nvs ( rb::Nvs ) ~Piezo ( rb::Piezo ) ~SmartServoBus ( rb::SmartServoBus ) ~StupidServo ( rb::StupidServo ) ~Timers ( rb::Timers ) ~Ultrasound ( rb::Ultrasound ) _ _T ( rb::Angle ) _rads ( rb::Angle )","title":"Class Members"},{"location":"api/class_members/#class-members","text":"","title":"Class Members"},{"location":"api/class_members/#a","text":"Angle ( rb::Angle ) auto_stop ( rb::SmartServoBus::servo_info ) auto_stop_counter ( rb::SmartServoBus::servo_info )","title":"a"},{"location":"api/class_members/#b","text":"BATTERY_IN_THRESHOLD ( rb::Battery ) Battery ( rb::Battery ) Buttons ( rb::Buttons ) byId ( rb::Buttons , rb::Leds ) blue ( rb::Leds ) buttons ( rb::Manager ) brake ( rb::Motor , rb::MotorChangeBuilder )","title":"b"},{"location":"api/class_members/#c","text":"Count ( rb::Buttons ) callback_t ( rb::Buttons , rb::Motor , rb::Ultrasound ) consumerRoutine ( rb::Manager ) consumerRoutineTrampoline ( rb::Manager ) coprocFwVersion ( rb::Manager ) coprocFwVersionAssert ( rb::Manager ) commit ( rb::Nvs ) cancel ( rb::Timers ) cancelByIdxLocked ( rb::Timers ) current ( rb::SmartServoBus::servo_info ) callback ( rb::Timers::timer_t )","title":"c"},{"location":"api/class_members/#d","text":"deg ( rb::Angle ) down ( rb::Buttons ) drive ( rb::Motor , rb::MotorChangeBuilder ) driveToValue ( rb::Motor , rb::MotorChangeBuilder ) disable ( rb::StupidServo ) deleteFreeRtOsTimerTask ( rb::Timers ) defaultSpeedOfSound ( rb::Ultrasound )","title":"d"},{"location":"api/class_members/#e","text":"existsInt ( rb::Nvs ) existsString ( rb::Nvs )","title":"e"},{"location":"api/class_members/#g","text":"green ( rb::Leds ) get ( rb::Manager , rb::Timers ) getInt ( rb::Nvs ) getString ( rb::Nvs ) getId ( rb::SmartServoBus ) getFreeIdLocked ( rb::Timers ) getSpeedOfSound ( rb::Ultrasound )","title":"g"},{"location":"api/class_members/#h","text":"hasValidCurrent ( rb::SmartServoBus::servo_info ) handle ( rb::Timers::timer_t )","title":"h"},{"location":"api/class_members/#i","text":"isNaN ( rb::Angle ) isPoweredByBattery ( rb::Battery ) install ( rb::Manager , rb::SmartServoBus ) id ( rb::Motor , rb::Timers::timer_t ) initFlash ( rb::Nvs ) INVALID_ID ( rb::Timers ) isOnTimerTask ( rb::Timers ) init ( rb::Ultrasound ) isLastMeasurementValid ( rb::Ultrasound )","title":"i"},{"location":"api/class_members/#k","text":"keepaliveRoutine ( rb::Manager )","title":"k"},{"location":"api/class_members/#l","text":"left ( rb::Buttons ) Leds ( rb::Leds ) limit ( rb::SmartServoBus ) lastDistanceMm ( rb::Ultrasound ) lastDurationUs ( rb::Ultrasound )","title":"l"},{"location":"api/class_members/#m","text":"m_state ( rb::Battery ) m_buttonsSet ( rb::Buttons ) m_callbacks ( rb::Buttons , rb::Ultrasound ) m_mutex ( rb::Buttons , rb::Leds , rb::Motor , rb::SmartServoBus , rb::StupidServo , rb::Timers , rb::Ultrasound ) m_ledsOn ( rb::Leds ) Manager ( rb::Manager ) m_battery ( rb::Manager ) m_buttons ( rb::Manager ) m_codec ( rb::Manager ) m_codecTxMutex ( rb::Manager ) m_coprocFwVersion ( rb::Manager ) m_coprocSemaphore ( rb::Manager ) m_coprocWatchdogTimer ( rb::Manager ) m_keepaliveTask ( rb::Manager ) m_leds ( rb::Manager ) m_motors ( rb::Manager ) m_motors_last_set ( rb::Manager ) m_piezo ( rb::Manager ) m_stupidServos ( rb::Manager ) m_txBuf ( rb::Manager ) m_ultrasounds ( rb::Manager ) monitorTask ( rb::Manager ) motor ( rb::Manager ) motorsFailSafe ( rb::Manager ) Motor ( rb::Motor ) m_id ( rb::Motor , rb::StupidServo ) m_infoCbs ( rb::Motor ) m_lastReq ( rb::Motor ) m_mode ( rb::Motor ) m_position ( rb::Motor ) m_positionCb ( rb::Motor ) m_power ( rb::Motor ) m_pwm_max_percent ( rb::Motor ) m_speed ( rb::Motor ) MotorChangeBuilder ( rb::MotorChangeBuilder ) m_calls ( rb::MotorChangeBuilder ) m_dirty ( rb::Nvs ) m_handle ( rb::Nvs ) m_on ( rb::Piezo ) m_servos ( rb::SmartServoBus ) m_lastPosition ( rb::StupidServo ) m_id_counter ( rb::Timers ) m_timers ( rb::Timers ) m_index ( rb::Ultrasound ) m_lastDistanceMm ( rb::Ultrasound ) m_lastUs ( rb::Ultrasound ) m_measuring ( rb::Ultrasound ) m_measuringDone ( rb::Ultrasound ) m_speedOfSound ( rb::Ultrasound ) m_timeoutTimer ( rb::Ultrasound ) measure ( rb::Ultrasound ) measureAsync ( rb::Ultrasound )","title":"m"},{"location":"api/class_members/#n","text":"nan ( rb::Angle ) Nvs ( rb::Nvs )","title":"n"},{"location":"api/class_members/#o","text":"operator*= ( rb::Angle ) operator+= ( rb::Angle ) operator- ( rb::Angle ) operator-= ( rb::Angle ) operator/= ( rb::Angle ) off ( rb::Buttons ) on ( rb::Buttons ) onChange ( rb::Buttons ) operator= ( rb::Manager ) onMotorStat ( rb::Motor ) onMeasuringDone ( rb::Ultrasound )","title":"o"},{"location":"api/class_members/#p","text":"Pi ( rb::Angle ) pct ( rb::Battery ) position ( rb::Motor , rb::StupidServo ) power ( rb::Motor , rb::MotorChangeBuilder ) pwmMaxPercent ( rb::Motor , rb::MotorChangeBuilder ) Piezo ( rb::Piezo ) pos ( rb::SmartServoBus ) posOffline ( rb::SmartServoBus )","title":"p"},{"location":"api/class_members/#r","text":"rad ( rb::Angle ) right ( rb::Buttons ) red ( rb::Leds ) resetMotorsFailSafe ( rb::Manager ) requestInfo ( rb::Motor ) regulateServo ( rb::SmartServoBus ) regulatorRoutine ( rb::SmartServoBus ) regulatorRoutineTrampoline ( rb::SmartServoBus ) reset ( rb::Timers ) recalculateLastDistanceLocked ( rb::Ultrasound )","title":"r"},{"location":"api/class_members/#s","text":"setState ( rb::Battery , rb::Buttons , rb::Piezo ) shutdown ( rb::Battery ) schedule ( rb::Manager , rb::Timers ) sendToCoproc ( rb::Manager ) setMotors ( rb::Manager ) stupidServo ( rb::Manager ) scale ( rb::Motor ) sendMotorReq ( rb::Motor ) sendPositionReq ( rb::Motor ) setConfig ( rb::Motor ) setCurrentPosition ( rb::Motor ) setId ( rb::Motor , rb::SmartServoBus , rb::StupidServo ) speed ( rb::Motor , rb::MotorChangeBuilder ) set ( rb::MotorChangeBuilder , rb::SmartServoBus ) start ( rb::Piezo ) stop ( rb::Piezo , rb::Timers ) SmartServoBus ( rb::SmartServoBus ) setAutoStop ( rb::SmartServoBus ) StupidServo ( rb::StupidServo ) sendServoMsg ( rb::StupidServo ) setPosition ( rb::StupidServo ) setSpeedOfSound ( rb::Ultrasound ) servo_info ( rb::SmartServoBus::servo_info ) speed_coef ( rb::SmartServoBus::servo_info ) speed_raise ( rb::SmartServoBus::servo_info ) speed_target ( rb::SmartServoBus::servo_info ) swap ( rb::Timers::timer_t )","title":"s"},{"location":"api/class_members/#t","text":"temperatureC ( rb::Battery ) timers ( rb::Manager ) Timers ( rb::Timers ) timerCallback ( rb::Timers ) target ( rb::SmartServoBus::servo_info )","title":"t"},{"location":"api/class_members/#u","text":"up ( rb::Buttons ) ultrasound ( rb::Manager ) Ultrasound ( rb::Ultrasound )","title":"u"},{"location":"api/class_members/#v","text":"VOLTAGE_MAX ( rb::Battery ) VOLTAGE_MIN ( rb::Battery )","title":"v"},{"location":"api/class_members/#w","text":"writeInt ( rb::Nvs ) writeString ( rb::Nvs )","title":"w"},{"location":"api/class_members/#y","text":"yellow ( rb::Leds )","title":"y"},{"location":"api/class_members/#_1","text":"~Battery ( rb::Battery ) ~Buttons ( rb::Buttons ) ~Leds ( rb::Leds ) ~Manager ( rb::Manager ) ~MotorChangeBuilder ( rb::MotorChangeBuilder ) ~Nvs ( rb::Nvs ) ~Piezo ( rb::Piezo ) ~SmartServoBus ( rb::SmartServoBus ) ~StupidServo ( rb::StupidServo ) ~Timers ( rb::Timers ) ~Ultrasound ( rb::Ultrasound )","title":"~"},{"location":"api/class_members/#_","text":"_T ( rb::Angle ) _rads ( rb::Angle )","title":"_"},{"location":"api/class_member_functions/","text":"Class Member Functions a Angle ( rb::Angle ) b Battery ( rb::Battery ) Buttons ( rb::Buttons ) byId ( rb::Buttons , rb::Leds ) blue ( rb::Leds ) buttons ( rb::Manager ) brake ( rb::Motor , rb::MotorChangeBuilder ) c consumerRoutine ( rb::Manager ) consumerRoutineTrampoline ( rb::Manager ) coprocFwVersion ( rb::Manager ) coprocFwVersionAssert ( rb::Manager ) commit ( rb::Nvs ) cancel ( rb::Timers ) cancelByIdxLocked ( rb::Timers ) d deg ( rb::Angle ) down ( rb::Buttons ) drive ( rb::Motor , rb::MotorChangeBuilder ) driveToValue ( rb::Motor , rb::MotorChangeBuilder ) disable ( rb::StupidServo ) deleteFreeRtOsTimerTask ( rb::Timers ) e existsInt ( rb::Nvs ) existsString ( rb::Nvs ) g green ( rb::Leds ) get ( rb::Manager , rb::Timers ) getInt ( rb::Nvs ) getString ( rb::Nvs ) getId ( rb::SmartServoBus ) getFreeIdLocked ( rb::Timers ) getSpeedOfSound ( rb::Ultrasound ) h hasValidCurrent ( rb::SmartServoBus::servo_info ) i isNaN ( rb::Angle ) isPoweredByBattery ( rb::Battery ) install ( rb::Manager , rb::SmartServoBus ) id ( rb::Motor ) initFlash ( rb::Nvs ) isOnTimerTask ( rb::Timers ) init ( rb::Ultrasound ) isLastMeasurementValid ( rb::Ultrasound ) k keepaliveRoutine ( rb::Manager ) l left ( rb::Buttons ) Leds ( rb::Leds ) limit ( rb::SmartServoBus ) lastDistanceMm ( rb::Ultrasound ) lastDurationUs ( rb::Ultrasound ) m Manager ( rb::Manager ) monitorTask ( rb::Manager ) motor ( rb::Manager ) motorsFailSafe ( rb::Manager ) Motor ( rb::Motor ) MotorChangeBuilder ( rb::MotorChangeBuilder ) measure ( rb::Ultrasound ) measureAsync ( rb::Ultrasound ) n nan ( rb::Angle ) Nvs ( rb::Nvs ) o operator*= ( rb::Angle ) operator+= ( rb::Angle ) operator- ( rb::Angle ) operator-= ( rb::Angle ) operator/= ( rb::Angle ) off ( rb::Buttons ) on ( rb::Buttons ) onChange ( rb::Buttons ) operator= ( rb::Manager ) onMotorStat ( rb::Motor ) onMeasuringDone ( rb::Ultrasound ) p pct ( rb::Battery ) position ( rb::Motor , rb::StupidServo ) power ( rb::Motor , rb::MotorChangeBuilder ) pwmMaxPercent ( rb::Motor , rb::MotorChangeBuilder ) Piezo ( rb::Piezo ) pos ( rb::SmartServoBus ) posOffline ( rb::SmartServoBus ) r rad ( rb::Angle ) right ( rb::Buttons ) red ( rb::Leds ) resetMotorsFailSafe ( rb::Manager ) requestInfo ( rb::Motor ) regulateServo ( rb::SmartServoBus ) regulatorRoutine ( rb::SmartServoBus ) regulatorRoutineTrampoline ( rb::SmartServoBus ) reset ( rb::Timers ) recalculateLastDistanceLocked ( rb::Ultrasound ) s setState ( rb::Battery , rb::Buttons , rb::Piezo ) shutdown ( rb::Battery ) schedule ( rb::Manager , rb::Timers ) sendToCoproc ( rb::Manager ) setMotors ( rb::Manager ) stupidServo ( rb::Manager ) scale ( rb::Motor ) sendMotorReq ( rb::Motor ) sendPositionReq ( rb::Motor ) setConfig ( rb::Motor ) setCurrentPosition ( rb::Motor ) setId ( rb::Motor , rb::SmartServoBus , rb::StupidServo ) speed ( rb::Motor , rb::MotorChangeBuilder ) set ( rb::MotorChangeBuilder , rb::SmartServoBus ) start ( rb::Piezo ) stop ( rb::Piezo , rb::Timers ) SmartServoBus ( rb::SmartServoBus ) setAutoStop ( rb::SmartServoBus ) StupidServo ( rb::StupidServo ) sendServoMsg ( rb::StupidServo ) setPosition ( rb::StupidServo ) setSpeedOfSound ( rb::Ultrasound ) servo_info ( rb::SmartServoBus::servo_info ) swap ( rb::Timers::timer_t ) t temperatureC ( rb::Battery ) timers ( rb::Manager ) Timers ( rb::Timers ) timerCallback ( rb::Timers ) u up ( rb::Buttons ) ultrasound ( rb::Manager ) Ultrasound ( rb::Ultrasound ) w writeInt ( rb::Nvs ) writeString ( rb::Nvs ) y yellow ( rb::Leds ) ~ ~Battery ( rb::Battery ) ~Buttons ( rb::Buttons ) ~Leds ( rb::Leds ) ~Manager ( rb::Manager ) ~MotorChangeBuilder ( rb::MotorChangeBuilder ) ~Nvs ( rb::Nvs ) ~Piezo ( rb::Piezo ) ~SmartServoBus ( rb::SmartServoBus ) ~StupidServo ( rb::StupidServo ) ~Timers ( rb::Timers ) ~Ultrasound ( rb::Ultrasound )","title":"Class Member Functions"},{"location":"api/class_member_functions/#class-member-functions","text":"","title":"Class Member Functions"},{"location":"api/class_member_functions/#a","text":"Angle ( rb::Angle )","title":"a"},{"location":"api/class_member_functions/#b","text":"Battery ( rb::Battery ) Buttons ( rb::Buttons ) byId ( rb::Buttons , rb::Leds ) blue ( rb::Leds ) buttons ( rb::Manager ) brake ( rb::Motor , rb::MotorChangeBuilder )","title":"b"},{"location":"api/class_member_functions/#c","text":"consumerRoutine ( rb::Manager ) consumerRoutineTrampoline ( rb::Manager ) coprocFwVersion ( rb::Manager ) coprocFwVersionAssert ( rb::Manager ) commit ( rb::Nvs ) cancel ( rb::Timers ) cancelByIdxLocked ( rb::Timers )","title":"c"},{"location":"api/class_member_functions/#d","text":"deg ( rb::Angle ) down ( rb::Buttons ) drive ( rb::Motor , rb::MotorChangeBuilder ) driveToValue ( rb::Motor , rb::MotorChangeBuilder ) disable ( rb::StupidServo ) deleteFreeRtOsTimerTask ( rb::Timers )","title":"d"},{"location":"api/class_member_functions/#e","text":"existsInt ( rb::Nvs ) existsString ( rb::Nvs )","title":"e"},{"location":"api/class_member_functions/#g","text":"green ( rb::Leds ) get ( rb::Manager , rb::Timers ) getInt ( rb::Nvs ) getString ( rb::Nvs ) getId ( rb::SmartServoBus ) getFreeIdLocked ( rb::Timers ) getSpeedOfSound ( rb::Ultrasound )","title":"g"},{"location":"api/class_member_functions/#h","text":"hasValidCurrent ( rb::SmartServoBus::servo_info )","title":"h"},{"location":"api/class_member_functions/#i","text":"isNaN ( rb::Angle ) isPoweredByBattery ( rb::Battery ) install ( rb::Manager , rb::SmartServoBus ) id ( rb::Motor ) initFlash ( rb::Nvs ) isOnTimerTask ( rb::Timers ) init ( rb::Ultrasound ) isLastMeasurementValid ( rb::Ultrasound )","title":"i"},{"location":"api/class_member_functions/#k","text":"keepaliveRoutine ( rb::Manager )","title":"k"},{"location":"api/class_member_functions/#l","text":"left ( rb::Buttons ) Leds ( rb::Leds ) limit ( rb::SmartServoBus ) lastDistanceMm ( rb::Ultrasound ) lastDurationUs ( rb::Ultrasound )","title":"l"},{"location":"api/class_member_functions/#m","text":"Manager ( rb::Manager ) monitorTask ( rb::Manager ) motor ( rb::Manager ) motorsFailSafe ( rb::Manager ) Motor ( rb::Motor ) MotorChangeBuilder ( rb::MotorChangeBuilder ) measure ( rb::Ultrasound ) measureAsync ( rb::Ultrasound )","title":"m"},{"location":"api/class_member_functions/#n","text":"nan ( rb::Angle ) Nvs ( rb::Nvs )","title":"n"},{"location":"api/class_member_functions/#o","text":"operator*= ( rb::Angle ) operator+= ( rb::Angle ) operator- ( rb::Angle ) operator-= ( rb::Angle ) operator/= ( rb::Angle ) off ( rb::Buttons ) on ( rb::Buttons ) onChange ( rb::Buttons ) operator= ( rb::Manager ) onMotorStat ( rb::Motor ) onMeasuringDone ( rb::Ultrasound )","title":"o"},{"location":"api/class_member_functions/#p","text":"pct ( rb::Battery ) position ( rb::Motor , rb::StupidServo ) power ( rb::Motor , rb::MotorChangeBuilder ) pwmMaxPercent ( rb::Motor , rb::MotorChangeBuilder ) Piezo ( rb::Piezo ) pos ( rb::SmartServoBus ) posOffline ( rb::SmartServoBus )","title":"p"},{"location":"api/class_member_functions/#r","text":"rad ( rb::Angle ) right ( rb::Buttons ) red ( rb::Leds ) resetMotorsFailSafe ( rb::Manager ) requestInfo ( rb::Motor ) regulateServo ( rb::SmartServoBus ) regulatorRoutine ( rb::SmartServoBus ) regulatorRoutineTrampoline ( rb::SmartServoBus ) reset ( rb::Timers ) recalculateLastDistanceLocked ( rb::Ultrasound )","title":"r"},{"location":"api/class_member_functions/#s","text":"setState ( rb::Battery , rb::Buttons , rb::Piezo ) shutdown ( rb::Battery ) schedule ( rb::Manager , rb::Timers ) sendToCoproc ( rb::Manager ) setMotors ( rb::Manager ) stupidServo ( rb::Manager ) scale ( rb::Motor ) sendMotorReq ( rb::Motor ) sendPositionReq ( rb::Motor ) setConfig ( rb::Motor ) setCurrentPosition ( rb::Motor ) setId ( rb::Motor , rb::SmartServoBus , rb::StupidServo ) speed ( rb::Motor , rb::MotorChangeBuilder ) set ( rb::MotorChangeBuilder , rb::SmartServoBus ) start ( rb::Piezo ) stop ( rb::Piezo , rb::Timers ) SmartServoBus ( rb::SmartServoBus ) setAutoStop ( rb::SmartServoBus ) StupidServo ( rb::StupidServo ) sendServoMsg ( rb::StupidServo ) setPosition ( rb::StupidServo ) setSpeedOfSound ( rb::Ultrasound ) servo_info ( rb::SmartServoBus::servo_info ) swap ( rb::Timers::timer_t )","title":"s"},{"location":"api/class_member_functions/#t","text":"temperatureC ( rb::Battery ) timers ( rb::Manager ) Timers ( rb::Timers ) timerCallback ( rb::Timers )","title":"t"},{"location":"api/class_member_functions/#u","text":"up ( rb::Buttons ) ultrasound ( rb::Manager ) Ultrasound ( rb::Ultrasound )","title":"u"},{"location":"api/class_member_functions/#w","text":"writeInt ( rb::Nvs ) writeString ( rb::Nvs )","title":"w"},{"location":"api/class_member_functions/#y","text":"yellow ( rb::Leds )","title":"y"},{"location":"api/class_member_functions/#_1","text":"~Battery ( rb::Battery ) ~Buttons ( rb::Buttons ) ~Leds ( rb::Leds ) ~Manager ( rb::Manager ) ~MotorChangeBuilder ( rb::MotorChangeBuilder ) ~Nvs ( rb::Nvs ) ~Piezo ( rb::Piezo ) ~SmartServoBus ( rb::SmartServoBus ) ~StupidServo ( rb::StupidServo ) ~Timers ( rb::Timers ) ~Ultrasound ( rb::Ultrasound )","title":"~"},{"location":"api/class_member_variables/","text":"Class Member Variables a auto_stop ( rb::SmartServoBus::servo_info ) auto_stop_counter ( rb::SmartServoBus::servo_info ) b BATTERY_IN_THRESHOLD ( rb::Battery ) c Count ( rb::Buttons ) current ( rb::SmartServoBus::servo_info ) callback ( rb::Timers::timer_t ) d defaultSpeedOfSound ( rb::Ultrasound ) h handle ( rb::Timers::timer_t ) i INVALID_ID ( rb::Timers ) id ( rb::Timers::timer_t ) m m_state ( rb::Battery ) m_buttonsSet ( rb::Buttons ) m_callbacks ( rb::Buttons , rb::Ultrasound ) m_mutex ( rb::Buttons , rb::Leds , rb::Motor , rb::SmartServoBus , rb::StupidServo , rb::Timers , rb::Ultrasound ) m_ledsOn ( rb::Leds ) m_battery ( rb::Manager ) m_buttons ( rb::Manager ) m_codec ( rb::Manager ) m_codecTxMutex ( rb::Manager ) m_coprocFwVersion ( rb::Manager ) m_coprocSemaphore ( rb::Manager ) m_coprocWatchdogTimer ( rb::Manager ) m_keepaliveTask ( rb::Manager ) m_leds ( rb::Manager ) m_motors ( rb::Manager ) m_motors_last_set ( rb::Manager ) m_piezo ( rb::Manager ) m_stupidServos ( rb::Manager ) m_txBuf ( rb::Manager ) m_ultrasounds ( rb::Manager ) m_id ( rb::Motor , rb::StupidServo ) m_infoCbs ( rb::Motor ) m_lastReq ( rb::Motor ) m_mode ( rb::Motor ) m_position ( rb::Motor ) m_positionCb ( rb::Motor ) m_power ( rb::Motor ) m_pwm_max_percent ( rb::Motor ) m_speed ( rb::Motor ) m_calls ( rb::MotorChangeBuilder ) m_dirty ( rb::Nvs ) m_handle ( rb::Nvs ) m_on ( rb::Piezo ) m_servos ( rb::SmartServoBus ) m_lastPosition ( rb::StupidServo ) m_id_counter ( rb::Timers ) m_timers ( rb::Timers ) m_index ( rb::Ultrasound ) m_lastDistanceMm ( rb::Ultrasound ) m_lastUs ( rb::Ultrasound ) m_measuring ( rb::Ultrasound ) m_measuringDone ( rb::Ultrasound ) m_speedOfSound ( rb::Ultrasound ) m_timeoutTimer ( rb::Ultrasound ) p Pi ( rb::Angle ) s speed_coef ( rb::SmartServoBus::servo_info ) speed_raise ( rb::SmartServoBus::servo_info ) speed_target ( rb::SmartServoBus::servo_info ) t target ( rb::SmartServoBus::servo_info ) v VOLTAGE_MAX ( rb::Battery ) VOLTAGE_MIN ( rb::Battery ) _ _rads ( rb::Angle )","title":"Class Member Variables"},{"location":"api/class_member_variables/#class-member-variables","text":"","title":"Class Member Variables"},{"location":"api/class_member_variables/#a","text":"auto_stop ( rb::SmartServoBus::servo_info ) auto_stop_counter ( rb::SmartServoBus::servo_info )","title":"a"},{"location":"api/class_member_variables/#b","text":"BATTERY_IN_THRESHOLD ( rb::Battery )","title":"b"},{"location":"api/class_member_variables/#c","text":"Count ( rb::Buttons ) current ( rb::SmartServoBus::servo_info ) callback ( rb::Timers::timer_t )","title":"c"},{"location":"api/class_member_variables/#d","text":"defaultSpeedOfSound ( rb::Ultrasound )","title":"d"},{"location":"api/class_member_variables/#h","text":"handle ( rb::Timers::timer_t )","title":"h"},{"location":"api/class_member_variables/#i","text":"INVALID_ID ( rb::Timers ) id ( rb::Timers::timer_t )","title":"i"},{"location":"api/class_member_variables/#m","text":"m_state ( rb::Battery ) m_buttonsSet ( rb::Buttons ) m_callbacks ( rb::Buttons , rb::Ultrasound ) m_mutex ( rb::Buttons , rb::Leds , rb::Motor , rb::SmartServoBus , rb::StupidServo , rb::Timers , rb::Ultrasound ) m_ledsOn ( rb::Leds ) m_battery ( rb::Manager ) m_buttons ( rb::Manager ) m_codec ( rb::Manager ) m_codecTxMutex ( rb::Manager ) m_coprocFwVersion ( rb::Manager ) m_coprocSemaphore ( rb::Manager ) m_coprocWatchdogTimer ( rb::Manager ) m_keepaliveTask ( rb::Manager ) m_leds ( rb::Manager ) m_motors ( rb::Manager ) m_motors_last_set ( rb::Manager ) m_piezo ( rb::Manager ) m_stupidServos ( rb::Manager ) m_txBuf ( rb::Manager ) m_ultrasounds ( rb::Manager ) m_id ( rb::Motor , rb::StupidServo ) m_infoCbs ( rb::Motor ) m_lastReq ( rb::Motor ) m_mode ( rb::Motor ) m_position ( rb::Motor ) m_positionCb ( rb::Motor ) m_power ( rb::Motor ) m_pwm_max_percent ( rb::Motor ) m_speed ( rb::Motor ) m_calls ( rb::MotorChangeBuilder ) m_dirty ( rb::Nvs ) m_handle ( rb::Nvs ) m_on ( rb::Piezo ) m_servos ( rb::SmartServoBus ) m_lastPosition ( rb::StupidServo ) m_id_counter ( rb::Timers ) m_timers ( rb::Timers ) m_index ( rb::Ultrasound ) m_lastDistanceMm ( rb::Ultrasound ) m_lastUs ( rb::Ultrasound ) m_measuring ( rb::Ultrasound ) m_measuringDone ( rb::Ultrasound ) m_speedOfSound ( rb::Ultrasound ) m_timeoutTimer ( rb::Ultrasound )","title":"m"},{"location":"api/class_member_variables/#p","text":"Pi ( rb::Angle )","title":"p"},{"location":"api/class_member_variables/#s","text":"speed_coef ( rb::SmartServoBus::servo_info ) speed_raise ( rb::SmartServoBus::servo_info ) speed_target ( rb::SmartServoBus::servo_info )","title":"s"},{"location":"api/class_member_variables/#t","text":"target ( rb::SmartServoBus::servo_info )","title":"t"},{"location":"api/class_member_variables/#v","text":"VOLTAGE_MAX ( rb::Battery ) VOLTAGE_MIN ( rb::Battery )","title":"v"},{"location":"api/class_member_variables/#_","text":"_rads ( rb::Angle )","title":"_"},{"location":"api/class_member_typedefs/","text":"Class Member Typedefs c callback_t ( rb::Buttons , rb::Motor , rb::Ultrasound ) _ _T ( rb::Angle )","title":"Class Member Typedefs"},{"location":"api/class_member_typedefs/#class-member-typedefs","text":"","title":"Class Member Typedefs"},{"location":"api/class_member_typedefs/#c","text":"callback_t ( rb::Buttons , rb::Motor , rb::Ultrasound )","title":"c"},{"location":"api/class_member_typedefs/#_","text":"_T ( rb::Angle )","title":"_"},{"location":"api/class_member_enums/","text":"Class Member Enums","title":"Class Member Enumerations"},{"location":"api/class_member_enums/#class-member-enums","text":"","title":"Class Member Enums"},{"location":"api/namespace_members/","text":"Namespace Members b ButtonId ( rb ) c clamp ( rb ) d delay ( rb ) delayMs ( rb ) dieTimers ( rb ) l LedId ( rb ) m ManagerInstallFlags ( rb ) MotorId ( rb ) o operator\"\"_deg ( rb ) operator\"\"_rad ( rb ) operator* ( rb ) operator+ ( rb ) operator++ ( rb ) operator- ( rb ) operator/ ( rb ) operator| ( rb ) s StupidServosCount ( rb ) u UltrasoundsCount ( rb )","title":"Namespace Members"},{"location":"api/namespace_members/#namespace-members","text":"","title":"Namespace Members"},{"location":"api/namespace_members/#b","text":"ButtonId ( rb )","title":"b"},{"location":"api/namespace_members/#c","text":"clamp ( rb )","title":"c"},{"location":"api/namespace_members/#d","text":"delay ( rb ) delayMs ( rb ) dieTimers ( rb )","title":"d"},{"location":"api/namespace_members/#l","text":"LedId ( rb )","title":"l"},{"location":"api/namespace_members/#m","text":"ManagerInstallFlags ( rb ) MotorId ( rb )","title":"m"},{"location":"api/namespace_members/#o","text":"operator\"\"_deg ( rb ) operator\"\"_rad ( rb ) operator* ( rb ) operator+ ( rb ) operator++ ( rb ) operator- ( rb ) operator/ ( rb ) operator| ( rb )","title":"o"},{"location":"api/namespace_members/#s","text":"StupidServosCount ( rb )","title":"s"},{"location":"api/namespace_members/#u","text":"UltrasoundsCount ( rb )","title":"u"},{"location":"api/namespace_member_functions/","text":"Namespace Member Functions c clamp ( rb ) d delay ( rb ) delayMs ( rb ) dieTimers ( rb ) o operator\"\"_deg ( rb ) operator\"\"_rad ( rb ) operator* ( rb ) operator+ ( rb ) operator++ ( rb ) operator- ( rb ) operator/ ( rb ) operator| ( rb )","title":"Namespace Member Functions"},{"location":"api/namespace_member_functions/#namespace-member-functions","text":"","title":"Namespace Member Functions"},{"location":"api/namespace_member_functions/#c","text":"clamp ( rb )","title":"c"},{"location":"api/namespace_member_functions/#d","text":"delay ( rb ) delayMs ( rb ) dieTimers ( rb )","title":"d"},{"location":"api/namespace_member_functions/#o","text":"operator\"\"_deg ( rb ) operator\"\"_rad ( rb ) operator* ( rb ) operator+ ( rb ) operator++ ( rb ) operator- ( rb ) operator/ ( rb ) operator| ( rb )","title":"o"},{"location":"api/namespace_member_variables/","text":"Namespace Member Variables s StupidServosCount ( rb ) u UltrasoundsCount ( rb )","title":"Namespace Member Variables"},{"location":"api/namespace_member_variables/#namespace-member-variables","text":"","title":"Namespace Member Variables"},{"location":"api/namespace_member_variables/#s","text":"StupidServosCount ( rb )","title":"s"},{"location":"api/namespace_member_variables/#u","text":"UltrasoundsCount ( rb )","title":"u"},{"location":"api/namespace_member_typedefs/","text":"Namespace Member Typedefs","title":"Namespace Member Typedefs"},{"location":"api/namespace_member_typedefs/#namespace-member-typedefs","text":"","title":"Namespace Member Typedefs"},{"location":"api/namespace_member_enums/","text":"Namespace Member Enums b ButtonId ( rb ) l LedId ( rb ) m ManagerInstallFlags ( rb ) MotorId ( rb )","title":"Namespace Member Enumerations"},{"location":"api/namespace_member_enums/#namespace-member-enums","text":"","title":"Namespace Member Enums"},{"location":"api/namespace_member_enums/#b","text":"ButtonId ( rb )","title":"b"},{"location":"api/namespace_member_enums/#l","text":"LedId ( rb )","title":"l"},{"location":"api/namespace_member_enums/#m","text":"ManagerInstallFlags ( rb ) MotorId ( rb )","title":"m"},{"location":"api/functions/","text":"Functions","title":"Functions"},{"location":"api/functions/#functions","text":"","title":"Functions"},{"location":"api/macros/","text":"Macros m M_PI ( RBCXAngle.h ) MAX_COPROC_IDLE_MS ( RBCXManager.cpp ) MOTORS_FAILSAFE_PERIOD_MS ( RBCXManager.cpp ) MS_TO_TICKS ( RBCXSmartServo.cpp ) r RBCX_ENUM_IMPL_MASK_OPERATORS ( RBCXUtil.h ) RB3204 ( RBCXVersion.h ) RB3204_MAJOR ( RBCXVersion.h ) RB3204_MINOR ( RBCXVersion.h ) RB3204_PATCH ( RBCXVersion.h ) RB3204_RBCX ( RBCXVersion.h ) RBCX ( RBCXVersion.h ) t TAG ( RBCXBattery.cpp , RBCXManager.cpp , RBCXSmartServo.cpp , RBCXUltrasound.cpp )","title":"Macros"},{"location":"api/macros/#macros","text":"","title":"Macros"},{"location":"api/macros/#m","text":"M_PI ( RBCXAngle.h ) MAX_COPROC_IDLE_MS ( RBCXManager.cpp ) MOTORS_FAILSAFE_PERIOD_MS ( RBCXManager.cpp ) MS_TO_TICKS ( RBCXSmartServo.cpp )","title":"m"},{"location":"api/macros/#r","text":"RBCX_ENUM_IMPL_MASK_OPERATORS ( RBCXUtil.h ) RB3204 ( RBCXVersion.h ) RB3204_MAJOR ( RBCXVersion.h ) RB3204_MINOR ( RBCXVersion.h ) RB3204_PATCH ( RBCXVersion.h ) RB3204_RBCX ( RBCXVersion.h ) RBCX ( RBCXVersion.h )","title":"r"},{"location":"api/macros/#t","text":"TAG ( RBCXBattery.cpp , RBCXManager.cpp , RBCXSmartServo.cpp , RBCXUltrasound.cpp )","title":"t"},{"location":"api/variables/","text":"Variables m minVersionPositional ( RBCXMotor.cpp )","title":"Variables"},{"location":"api/variables/#variables","text":"","title":"Variables"},{"location":"api/variables/#m","text":"minVersionPositional ( RBCXMotor.cpp )","title":"m"}]}